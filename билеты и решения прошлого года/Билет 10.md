# Билет №10

## 1. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.

**Модификаторы уровня доступа** – специальные ключевые слова, описывающие, на каком уровне программы должен быть доступ к соответствующему классу, методу или полю.

> Под доступом здесь понимается "а можно ли из метода класса A обратиться к методу класса B", и всё в таком духе.

В госах вопросы строятся по `Java`, а в ней есть четыре типа доступа:

- `public`, когда доступ разрешён отовсюду, без ограничений;

```java
public static void visibleEverywhere() {}
```

- `protected`, когда доступ разрешён только для дочерних классов и классов текущего пакета;

```java
protected static void inSubclasses() {}
```

- `default` или отсутствие модификатора, когда доступ разрешён только для классов текущего пакета;

```java
static void inPackage() {}
```

- `private`, когда доступ разрешён только в пределах текущего класса.

```java
private void inClass() {}
```

## 2. Мультипроцессорные вычислительные системы, их производительность, применение и разновидности.

**MIMD** или **multiple instruction stream / multiple data stream** – множественный поток команд и множественный поток данных.
Современные компы.

>В системе есть много процессоров, объединённых в единый комплекс и работающих каждый со своим потоком команд и данных.

**Многопроцессорные вычислительные системы** – это системы, содержащие несколько процессоров, информационно взаимодействующих между собой либо на уровне регистров процессорной памяти, либо на уровне оперативной памяти.

**Мультипроцессор** – это подкласс *многопроцессорных* компьютерных систем, где есть несколько процессоров и одно адресное пространство, видимое для всех процессоров. Мультипроцессор запускает одну копию ОС с одним набором таблиц, в том числе тех, которые следят какие страницы памяти свободны.

> Мультипроцессоры, как и прочие кластерные системы, нужны для больших вычислений – они позволяют решать задачи с огромным количеством обрабатываемых данных.

Для мультипроцессорных систем используют модульный принцип построения, позволяющий наращивать их структуру, решать проблемы надежности, а также снижать стоимость производства.

Под **модулем** понимают любое функциональное устройство вычислительной системы с собственным управлением, способное функционировать самостоятельно под воздействием команд процессора. Наличие однотипных модулей в вычислительных системах дает возможность переключать потоки информации при обнаружении неисправностей в модулях: система изменяет свои параметры, но сохраняет работоспособность.

> Модульность аппаратных средств повышает отказоустойчивость вычислительной системы.

Территориальную распределенность мультипроцессор не поддерживает – все его блоки располагаются в одном или нескольких близко расположенных конструктивах, как и у обычного компьютера.

Основное достоинство мультипроцессора – его высокая производительность, которая достигается за счет параллельной работы нескольких процессоров. Так как при наличии общей памяти взаимодействие процессоров происходит очень быстро, мультипроцессоры могут эффективно выполнять даже приложения с высокой степенью связи по данным.

Различают пиковую (*теоретическая*) и реальную производительность.

**Пиковая производительность** – произведение пиковой производительности одного процессора на число таких процессоров в данной машине, если предположить, что все устройства компьютера работают в максимально производительном режиме.

Оценить пиковую производительность можно двумя способами:

- Использовать в оценке число команд, выполняемых компьютером в единицу времени.
  Измеряется в **MIPS** (Million Instructions Per Second).

  > Очень специфично и зависит от программ. Даёт лишь самое общее представление о производительности компьютера.

- Использовать в оценке число вещественных операций, выполняемых компьютером в единицу времени.
  Измеряется в **FLOPS** (Floating point operations per second).

  > Позволяет узнать нижнюю оценку времени выполнения для каждой из программ.

>Чем больше **пиковая** производительность, тем **теоретически** быстрее пользователь сможет решить свою задачу.

**Реальная производительность** – производительность, достигаемая в работе с определённым приложением. Зависит от взаимодействия программной модели, в которой реализовано приложение, с архитектурными особенностями машины, на которой приложение запускается.

Определить реальную производительность можно с помощью специальных тестирующих программ – **бенчмарков**.

> Чем больше **реальная** производительность, тем **фактически** быстрее пользователь сможет решить свою задачу.

**Мультипроцессоры классифицируются на:**

> Это свойство позволяет характеризовать как тип архитектуры мультипроцессорной системы, так и способ организации вычислительного процесса в системе.

- **Симметричные мультипроцессоры (SMP).**
  Предполагает однородность всех процессоров и единообразие их включения в общую схему мультипроцессорной системы.
  Процессоры в SMP пользуются одной ОЗУ и должны располагаться в одном системном блоке. Это ограничивает масштабирование до 4-8 процессоров. Зато, они могут очень быстро обмениваться данными.
- **Ассиметричные мультипроцессоры (AMP).**
  Разные процессоры могут отличаться как своими характеристиками, так и функциональной ролью в системе.
  Функциональная неоднородность влечёт за собой структурные отличия во фрагментах системы, содержащих разные процессоры системы: они могут быть физически расположены в разных устройствах с разной технической реализацией.
  Наиболее простая конструкция (на ней базируется идея кластера), функционирует по принципу "ведущий-ведомый".

## 3. Виды интерфейсов операционных систем ОС.

**Операционная система** – комплекс программ, обеспечивающй взаимодействие всех устройств ЭВМ и позволяющий поользователю осуществлять управление ЭВМ.

> ОС – посредник между пользователем, программами и оборудованием компа.

**Главное назначение ОС** – управление ресурсами, главными из которых является аппаратура компьютера. ОС управляет вычислительным процессом и информационным обменом между процессором, памятью, внешними устройствами.

Основным интерфейсом ОС является **интерфейс системных вызовов** (**API OS**). **Системным вызовом** называется обращение процесса к ядру ОС для выполнения какой-либо операции, например чтения файла.

В общем случае, ОС обладает пользовательским интерфейсом – набором приёмов взаимодействия пользователя с приложениями и функционалом ОС. Интерфейсы отличаются между собой по способу управления ПО. В настоящее время, выделяют три основных вида пользовательских интерфейсов:

1. **Командный (текстовый) интерфейс**.
   Взаимодействие осуществляется через текстовые команды. Ориентированы на однозадачность, сравнительно быстрые ввиду отсутствия графики, однако работа невозможна без знания специальных команд.

   > Far Manager, MS-DOS, терминал Linux.

2. **Графический интерфейс**.
   Взаимодействие осуществляется через графические обозначения, посредством различных периферийных устройств (мышь, клавиатура, сенсорный экран). Ориентированы на многозадачность, но сравнительно медленные из-за подгрузки графики. Зато, работать с ними можно на интуитивном уровне.

   > MS Word, PyCharm, проводник Windows, Gnom Shell.

3. **Голосовой интерфейс**.
   Взаимодействие осуществляется через голосовые команды человека. В настоящее время, полноценное управление ОС голосовым интерфейсом невозможно. Сам интерфейс является перспективным, однако качество распознавания устной речи ещё далеко от полноценного применения. Требовательна к аппаратной части (нужен мощный комп).

   > Kortana, GLaDOS.

## 4. Задача

Составьте программу «Автозаправка». На форме укажите сумму денег, на которую необходимо купить бензин, тип бензина выбирается из списка (76,92, 96). Каждый тип бензина имеет свою цену. Вычислите количество бензина, которое можно купить на заданную сумму и наоборот указать количество бензина и вычислить сумму денег.

****

### **Консольная версия**

```python
fuel = {
    '76': 100,
    '92': 120,
    '96': 85,
}

# Сколько стоит количество бензина
def calculate_fuel(fuel_code, fuel_count):
    price = 0
    fuel_code = str(fuel_code)
    if fuel_code in fuel:
        price = fuel[fuel_code] * fuel_count
    return price

# Сколько бензина можно купить на сумму
def calculate_price(fuel_code, fuel_price):
    fuel_count = 0
    fuel_code = str(fuel_code)
    if fuel_code in fuel:
        fuel_count = fuel_price / fuel[fuel_code]
    return fuel_count

calculate_fuel(92, 3)
calculate_price(92, 333)
```

### Версия для паскаля

```pascal
uses FormsABC;

var
v1 := new RealField('Рублей:');
s1 := new Space(30);
v2 := new RealField('Литров:');

f1 := new FlowBreak(10);

b1 := new Button('Вычислить литры');
s2 := new Space(25);
b2 := new Button('Вычислить стоимость');

f2 := new FlowBreak(10);

t1 := new TextLabel('Выберите тип бензина:');

actions := new ComboBox();
Price: array of integer;

procedure CountOfLiters;
var
liters: real;
begin
v2.Value := Round(v1.Value/price[actions.SelectedIndex],2);
end;

procedure CountOfValue;
begin
v1.Value := Round(v2.Value*price[actions.SelectedIndex],2);
end;

begin
SetLength(Price,3);

b1.Click += CountOfLiters;
b2.Click += CountOfValue;

for var i := 0 to Price.Length-1 do
begin
price[i] := Random(100)+20;
end;
actions.Items.Add('"76" - '+price[0]+'р. за литр');
actions.Items.Add('"92" - '+price[1]+'р. за литр');
actions.Items.Add('"96" - '+price[2]+'р. за литр');
actions.SelectedIndex := 0;

end.
```

