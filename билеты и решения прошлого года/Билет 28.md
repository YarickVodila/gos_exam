# Билет №28

## 1. Назначение и функции сетевых устройств, особенности широковещательных запросов.

### 1.1. Повторитель (Repeater)

Данные передаются по кабелям. Кабели – физическая среда передачи данных. У физической среды передачи данных есть ограничение: чем дальше от источника, тем слабее сигнал.

Повторитель – устройство, которое на физическом уровне воспроизводит сигнал и отправляет его дальше: то есть, повторяет сигнал и фактически усиливает источник сигнала. Буквально воспроизводит биты сигнала.

Повторитель (в такой простейшей форме) имеет всего два порта: вход и выход.

> Костры в цепи сигнальных огней между Гондором и Роханом – повторители сигнала, но от каждого костра можно послать сигнал лишь на один костёр.

### 1.2. Концентратор (Hub)

Существуют многопортовые повторители, обладающие большим количеством портов – концентраторы.

Концентратор – сетевое устройство для распространения сигнала в сети. Все приходящие на порт данные пересылаются на все другие порты концентратора.

Помимо функционала повторителя (усиление и распространение сигнала), фактически позволяет объединять устройства в сеть.

> Концентратор – продвинутая версия повторителя: теперь в зоне видимости костра можно зажечь дохрена других таких же костров (правило применяется к каждому костру на карте).

Концентратор также имеет дополнительный функционал (с большой силой приходит большая ответственность за сеть):

1. **Отключение порта.** Концентратор может отключать некорректно работающие порты;
2. **Резервирование портов.** Можно забить часть портов как резервные;
3. **Защита портов.** Можно шифровать порты, либо присваивать порту MAC-адрес подключенной к нему станции.

Концентраторы бывают разными:

- **Пассивные концентраторы.** Тупо пересылают данные;
- **Активные концентраторы.** Перед ретрансляцией, данные анализируются на предмет ошибок, после чего концентратор пытается их пофиксить. Слабый сигнал может быть усилен;
- **Гибридные концентраторы.** Концентраторы, в которые можно подключить кабели разных типов.

### 1.3. Мост (Bridge)

Концентратор транслирует данные на все порты кроме входящего. Но, когда в сети устройств больше чем несколько, это приводит к огромной нагрузке. Следовательно, большие сети надо формировать через более продвинутые устройства.

**Мост** – сетевое устройство для виртуального преобразования большой сети в сеть, формирующуюся из сегментов. Это как большой камень, разбитый на части и сцепленный наножвачкой.

Работает на канальном уровне: устройство может и должно работать с MAC-адресами, что невозможно на физическом уровне. Каждый порт моста закреплён под конкретный фрагмент сети – это позволяет не просто управлять отдельными мелкими сетями, но формировать из них большую.

> Мосты выполняют три важных функции: анализ, фильтрацию и пересылку.
>
> Фактически, мост снижает трафик в сети путём разделения большой сети на фрагменты – он объединяет эти фрагменты и эффективно управляет ими, даже если у них отличаются протоколы на физическом или канальном уровне.

**Чем мосты хороши:**

1. Относительно просто и дёшево объединяют локальные сети;
2. "Локальные" кадры одной сети остаются в своём сегменте сети (никаких цыган в Индии);
3. Присутствие мостов прозрачно для пользователей;
4. Так как мосты объединяют локальные сети в логически единую сеть, то перемещение компьютера между этими сетями не требует изменения его сетевого адреса.

**Чем мосты плохи:**

1. Возводит путь в абсолют – из возможных путей всегда выибрается один (не поддерживает альтернативные пути);
2. Не может изолировать косячные сегменты сети (если у вас в комнате поселился Зигмунд Фрейд, то это навсегда);
3. Дополнительная задержка кадров;
4. Если передаётся кадр, адрес которого ещё не содержится в таблице моста, то он передаётся во все сегменты. То есть, мост может способствовать значительным всплескам трафика в сети.

Мосты могут иметь разный принцип работы, но на практике выжил только прозрачный мост (только он работает с Ethernet). Остальные мосты базируются на идее прозрачного моста:

**Прозрачный мост.**
Предназначен для объединения сетей с идентичными протоколами на канальном и физическом уровнях.
Присутствие и работа моста являются прозрачными для хостов сети.
Прозрачный мост является самообучающимся устройством – он для каждого подключенного сегмента автоматически строит таблицу с MAC-адресами и их портами (адресную таблицу). В сетевом контексте это означает одну большую сеть с единым сетевым адресом и разными MAC-адресами.
Пересылка данных внутри сегмента игнорируется мостом, а между разными сегментами – проводится им по адресной таблице (если нужного адреса не нашлось – рассылка всем).

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1iOBfy4mA3dB-uU7_f1jJK-RZdiWgX87k" style=" zoom: 20%;"><b><p style="text-align: center;">Схема прозрачного моста</p></b></p>

### 1.4. Коммутатор (Switch)

Мосты делят большую сеть на сегменты, и составляют сеть из сегментов. Однако, в сетях часто нужен ещё один слой сегментации: когда разделяются не только сегменты сети, но и устройства (компудахтеры).

Коммутатор – сетевое устройство, конструктивно выполненное в виде сетевого концентратора, и действующее как высокоскоростной многопортовый мост. У него есть встроенный механизм коммутации, с помощью которого локальные сети имеют широковещательное сегментирование, а рабочие станции – выделенную полосу пропускания к себе.

> То есть, коммутатор – концентратор с прибамбассами, который работает как высокоскоростной мост с кучей портов.

Коммутатор способен «запоминать» адрес каждого компьютера, подключённого к его портам и передавать данные на компьютер адресата.

> Управляемый коммутатор – коммутатор с микропроцессором, который может кастовать лютую дичь (узкоспециализированный компьютер)
>
> Неуправляемый коммутатор – тупая штуковина без микропроцессора.

**Коммутатор также работает на канальном уровне и может вытворять следующие фокусы:**

- Создание и поддержка виртуальных сетей;
- Поддержка протоколов STP;
- Маршрутизация кадров;
- Фильтрация и контроль трафика;
- Передача данных с порта на порт.

**Коммутатор также имеет несколько режимов работы – о них слышал каждый школьник**:

- **Полудуплексный режим работы.**
  Одновременно лишь одно устройство может передавать данные.

  > Односторонняя одновременная передача.

- **Дуплексный режим работы.**
  Отправитель и получатель могут одновременно обмениваться данными.

  > Двусторонняя одновременная передача.

### 1.5 Маршрутизатор (Router)

**Маршрутизатор** – устройство, работающее на сетевом уровне модели OSI, и обеспечивающее поиск пути от источника до получателя. Оно использует одну или более метрик для определения оптимального пути передачи сетевого трафика на основании информации сетевого уровня.

> Маршрутизатор умеет очень гибко управлять трафиком, но обладает сравнительно низкой производительностью, L3-коммутатор же обладает высокой производительностью, но практически ничего не умеет.

Функции маршрутизатора:

- Чтение заголовков пакетов сетевых протоколов;
- Построение таблицы маршрутизации на основе протоколов маршрутизации;
- Определении на еë основе маршрута;
- Буферизация;
- Фрагментация;
- Фильтрация поступающих пакетов;
- Поддержка сетевых интерфейсов.

### 1.6 Широковещательная рассылка

**Широковещательная рассылка** — процесс отправки пакета с одного узла на все узлы в сети.

> Широковещательная рассылка – это передача информации от одного устройства всем остальным устройствам.

Широковещательная рассылка связана с устройством, отправляющее сообщение всем остальным устройствам в сети в режиме «один-ко всем».

Пакет широковещательной рассылки содержит IPv4-адрес назначения, узловая часть которого состоит только из единичных битов — широковещательный адрес. Широковещательные пакеты есть в IPv4, но отсутствуют в IPv6.

Широковещательный пакет должен обрабатываться всеми устройствами в одном домене широковещательной рассылки. Домен широковещательной рассылки идентифицирует все узлы в одном сегменте сети. По умолчанию, маршрутизаторы не пересылают широковещательные рассылки.

Широковещательный пакет использует ресурсы в сети и заставляет каждый принимающий узел в сети обрабатывать этот пакет. Таким образом, трафик широковещательной рассылки должен быть ограниченным, чтобы не влиять на производительность сети и других устройств. Поскольку маршрутизаторы разделяют домены широковещательной рассылки, разделение сетей может повысить производительность сети за счет устранения чрезмерного трафика широковещательной рассылки.

## 2. Механизмы защиты операционной системы Unix.

**Операционная система** – комплекс программ, обеспечивающй взаимодействие всех устройств ЭВМ и позволяющий поользователю осуществлять управление ЭВМ.

> ОС – посредник между пользователем, программами и оборудованием компа.

**Главное назначение ОС** – управление ресурсами, главными из которых является аппаратура компьютера. ОС управляет вычислительным процессом и информационным обменом между процессором, памятью, внешними устройствами.

**UNIX** – это многопользовательская, многозадачная ОС, включает в себя достаточно мощные средства защиты программ и файлов различных пользователей. Написана на языке С и является машинно-независимой, что обеспечивает её высокую мобильность и лёгкую переносимость прикладных программ на ПК различной архитектуры.

Важной особенностью ОС семейства UNIX является её модульность и обширный набор сервисных программ, которые позволяют создать благоприятную операционную обстановку для пользователей-программистов.

Защита ОС семейства Unix базируется на трёх основных механизмах, основным из которых являются права доступа:

- **Разделение прав пользователей.**
  Запущенные одним пользователем процессы не доступны для других пользователей. Исключением служит суперпользователь root, который имеет абсолютные права на всё. От имени этого пользователя также происходит запуск системных процессов при инициализации ОС.
  Разделение прав включает в себя существование прав на доступ к файлам. У каждого файла есть владелец и группа владельца. Права определяются по девятибитной маске. Каждые три бита определяют права на чтение, запись и исполнение файла сначала для владельца, потом для группы, а потом для всех остальных.

  > Обычные правила разграничения доступа к ROOT не применяются - ему доступна вся информация на компьютере.
  >
  > I'AM ROOOOOT!

- **Идентификация и аутентификация пользователя при входе в систему.**
  Изначально заложена в UNIX, которая поддживает список именованных пользователей. Посредством этого списка можно осуществлять разделение прав пользователей.

- **Регистрация событий (аудит).**
  C её помощью можно получить подробную информацию обо всех системных событиях.
  Она не обеспечивает никакой дополнительной защиты, но предоставляет подробную информацию о нарушениях безопасности, на основании которой можно принять конкретные меры.

  > Подсистема аудита отслеживает критические, с точки зрения безопасности, системные события: запуск и завершение работы системы, взаимодействие с файлами, изменение сетевых настроек, запуск и остановка приложений, инициация сетевых соединений и тыпы, выполнение системных вызовов.

<p style="text-align: center;"><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/00c/0a2/dc2/00c0a2dc2ce9add68219858fa1f88e9c.png" style=" zoom: 50%;"><b><p style="text-align: center;">Безопасность и ведро ОС UNIX</p></b></p>

## 3. Типы данных Python, динамическая типизация.

Python – своеобразный язык в контексте типизации. Во многих привычных языках, разработчик должен сам задавать типы при объявлении или инициализации переменных.

> Так, всё в пайтоне представляет собой объекты – числа, функции, классы, списки, модули и так далее.
>
> Когда объявляется переменная, функция и всякаоае такое – оно начинает хранить в себе **ссылку** на соответствующий объект в памяти.

Однако, python основывается на особой концепции типизации – **динамической типизации**. Типы объектов определяются автоматически во время выполнения кода: переменная никогда не располагает информацией о своём типе или его ограничениях, она просто ссылается на определённый объект (а вот этот объект уже и обладает информацией о типе).

В пайтоне буквально всё взаимодействует через присваивание и ссылки, как раз благодаря динамической типизации. Работает это через **утиную типизацию**: при работе с объектом, проверяется не его тип, а свойства и методы данного объекта.

> Если это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть грёбаная утка.

В пайтоне представлен следующий ряд встроенных типов:

- **Числа**. Могут быть целыми (`int`), вещественными (`float`), комплексными (complex). Неизменяемый тип данных (при "изменении", создаётся новый объект).

>`Пример`: 1234, 3.905, 3+4j, 0b111

- **Строки**. Упорядоченные последовательности символов. Неизменяемый тип данных.

>Пример: 'Строка', "Элвис жив", b'a\x01c'

- **Списки**. Аналог массива, представляет собой связный список (массив указателей).

>Пример: [1, true, 'Шакурас', ['А чо в смысле']], [1, 2, 3]

- **Словари**. Как массив, но вместо индексов использует ключи. Буквально словарь – работа с данными идёт по *уникальному* ключу. В основе лежит хеш-таблица.

>Пример: {'Уточка': 'Жёлтая', 'Смысл': 42}

- **Кортежи**. Неизменяемая версия списков.

>Пример: (1, 9, 'Боб', 'Алиса')

- **Множества**. Неупорядоченный список, который может содержать только уникальные данные.

>Пример: (1, 0, 5, true, None)

- **Прочие основные типы**. Разные типы, согласно Лутцу.

>Пример: Булевские значения, типы объектов, None, функции, модули, классы.

## 4. Задача

Разработайте программу «Управление роботом». В программе организовать движение робота по экрану, с возможностью управления с клавиатуры (возможно бой язык программирования).

****

```python
import tkinter as tk

# Константы
X, Y = 800, 800  # Ширина и высота окна

def move(event):
    global robot
    robot_step = 8
    robot_position = canvas.coords(robot)
    if event.keysym=='Up' and robot_position[1] > robot_step:
        canvas.move(robot, 0, -robot_step)
    elif event.keysym=='Down' and robot_position[3] < Y-robot_step:
        canvas.move(robot, 0, robot_step)
    elif event.keysym=='Right' and robot_position[2] < X-robot_step:
        canvas.move(robot, robot_step, 0)
    elif event.keysym=='Left' and robot_position[0] > robot_step:
        canvas.move(robot, -robot_step, 0)

if __name__ == '__main__':
    window = tk.Tk()

    # Задание параметров экземпляра окна
    window.title('Движение робота')
    window.geometry(f'{X}x{Y}')
    window.resizable(width=False, height=False)
    
    # Задание робота
    canvas = tk.Canvas(window, bg='white', height=X, width=Y)
    robot = canvas.create_oval(180, 10, 280, 110,fill="grey")
    canvas.bind_all('<Key>', move);
    
    # Инициализация движения
    canvas.pack()
    
    # Показ экземпляра окна
    window.mainloop()
```