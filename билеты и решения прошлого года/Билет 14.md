# Билет №14

## 1. Графы. Кратчайшие расстояния.

**Граф** – математическая модель набора связей (отношений). То есть, это наглядное представление отношений между какими-либо объектами.

> В математическом виде, граф: (V, E, $\phi$). V – множество вершин, E – множество рёбер, $\phi$ – отношения между ними.

**Обход графа** – это переход от одной его вершины к другой в поисках свойств связей этих вершин. Связи (линии, соединяющие вершины) называются **рёбрами** графа, а вершины  – **узлами**. Если у узла нет потомков, он называется **листом**.

**Путь в графе** – некая последовательность вершин, каждая из которых соединена со следующей ребром. Численно путь характеризуется суммой весов этих рёбер.

**Ориентированный граф** – граф, рёбра которого имеют направление. То есть, из вершины 1 может быть дуга в вершину 2, но не всегда будет дуга из вершины 2 в вершину 1. В орграфе у ребра всегда есть начало и конец.

**Неориентированный граф** – граф, рёбра которого не имеют направления. То есть, если есть ребро между вершинами – из первой вершины всегда можно попасть во вторую, а из второй вершины – в первую.

Одной из актуальнейших задач, связанных с графами, является задача поиска кратчайшего пути из одной вершины в другую.

**Кратчайший путь** от одной вершины графа к другой – это путь, при котором сумма весов рёбер, его составляющих, должна быть минимальна. **Длиной пути** может, контекстно, считаться либо число рёбер, либо число промежуточных вершин, либо суммарное число вершин.

Кратчайший путь между парой вершин не всегда уникален – могут быть альтернативы.

> Как юниту быстрее всего попасть в нужную зону локации?
> Как замутить минимальную задержку сигнала?

**Взвешенный граф** – граф, у которого каждому ребру сопоставлено некое число (**вес**).

Есть два основных решения данной задачи: алгоритм Дейкстры и алгоритм Беллмана-Форда. Её можно также решить через поиск в ширину, алгоритм Флойда, но алгоритм Дейкстры гораздо круче.

### Алгоритм Дейкстры

Алгоритм Дейкстры находит кратчайшие пути от одной из вершин графа до всех остальных. Работает только с направленными ациклическими (без циклов) графами без рёбер с отрицательным весом.

> Алгоритм Дейкстры работает на том основании, что любой подпуть B -> D кратчайшего пути A -> D между вершинами A и D также является кратчайшим путем между вершинами B и D.

Данный алгоритм состоит из шагов:

1. Найти узел с наименьшей стоимостью;
2. Проверить, существует ли более дешёвый путь к соседям этого узла, и если существует – обновить их стоимости;
3. Повторять, пока не будут пройдены все узлы;
4. Profit! Вес каждой вершины = вес пути до неё из начальной вершины. Если бесконечность – в неё не попасть из стартовой вершины.

<p style="text-align: center;"><img src="https://evileg.com/media/users/mafulechka/photos/photo_qRhnT3q.jpg" style=" zoom: 80%;"><b><p style="text-align: center;">Алгоритм Дейкстры</p></b></p>

### Алгоритм Беллмана-Форда

**НЕОБЯЗАТЕЛЕН, МОЖНО ВООБЩЕ ЗАБИТЬ НА НЕГО.**

Алгоритм Беллмана-Форда находит в ориентированном графе кратчайшие пути от исходной вершины до всех остальных. В отличие от алгоритма Дейкстры допускает обработку рёбер с отрицательным весом и может даже обнаруживать отрицательные циклы.

> Алгоритм Беллмана-Форда плохо масштабируется, но применим к любым графам. Хорошо подходит для распределённых систем.
>
> Если встречает цикл отрицательного веса – уходит в бесконечный цикл.

В простейшем случае, суть алгоритма следующая:

1. Расстояние от исходной вершины до всех остальных объявляется как бесконечность, а до исходной – как ноль. Создаётся массив для всех бесконечных значений. На i-й итерации он хранит ответ на задачу для i рёбер входящих в путь;
2. Вычисляются самые короткие расстояния – нужно пройти по каждому ребру и попробовать улучшить расстояние до вершин, которые оно соединяет. Выполняется столько раз, сколько вершин в графе (т.е, в массиве бесконечных значений, куда не входит исходная вершина).

## 2. Классификация машин по Флинну.

**Классификация Флинна** – общая классификация архитектур ЭВМ по признакам наличия параллелизма в потоках команд и данных.

Классификация базируется на понятии **потока**, под которым понимается *последовательность элементов, команд или данных, обрабатываемая процессором*. 

На основе числа потоков команд и потоков данных Флинн выделяет четыре класса архитектур:

- **SISD** или **single instruction stream / single data stream** – одиночный поток команд и одиночный поток данных.
  Первые компы, такие как МЭСМ или ABC. Первый суперкомпьютер CDC 6600.

  >В таких компах есть только один поток команд, все команды обрабатываются последовательно друг за другом, и каждая команда запускает одну операцию с одним потоком данных.

- **SIMD** или **single instruction stream / multiple data stream** – одиночный поток команд и множественный поток данных.
  Комповые прототипы вроде illiac, суперкомпьютеры 70-х, вроде CRAY-1.

  >В таких компах есть только один поток команд, но он поддерживает векторные команды – одну арифметическую операцию можно выполнять сразу над многими данными.

- **MISD** или **multiple instruction stream / single data stream** – множественный поток команд и одиночный поток данных.
  В реальности, таких компов пока что нет.

  >В системе есть много процессоров, обрабатывающих один и тот же поток данных.

- **MIMD** или **multiple instruction stream / multiple data stream** – множественный поток команд и множественный поток данных.
  Современные компы.

  >В системе есть много процессоров, объединённых в единый комплекс и работающих каждый со своим потоком команд и данных.

## 3. Задача

Составьте программу «Автозаправка». На форме укажите сумму денег, на которую необходимо купить бензин, тип бензина выбирается из списка (76,92, 96). Каждый тип бензина имеет свою цену. Вычислите количество бензина, которое можно купить на заданную сумму и наоборот указать количество бензина и вычислить сумму денег.

****

### **Консольная версия**

```python
fuel = {
    '76': 100,
    '92': 120,
    '96': 85,
}

# Сколько стоит количество бензина
def calculate_fuel(fuel_code, fuel_count):
    price = 0
    fuel_code = str(fuel_code)
    if fuel_code in fuel:
        price = fuel[fuel_code] * fuel_count
    return price

# Сколько бензина можно купить на сумму
def calculate_price(fuel_code, fuel_price):
    fuel_count = 0
    fuel_code = str(fuel_code)
    if fuel_code in fuel:
        fuel_count = fuel_price / fuel[fuel_code]
    return fuel_count

calculate_fuel(92, 3)
calculate_price(92, 333)
```

### Версия для паскаля

```pascal
uses FormsABC;

var
v1 := new RealField('Рублей:');
s1 := new Space(30);
v2 := new RealField('Литров:');

f1 := new FlowBreak(10);

b1 := new Button('Вычислить литры');
s2 := new Space(25);
b2 := new Button('Вычислить стоимость');

f2 := new FlowBreak(10);

t1 := new TextLabel('Выберите тип бензина:');

actions := new ComboBox();
Price: array of integer;

procedure CountOfLiters;
var
liters: real;
begin
v2.Value := Round(v1.Value/price[actions.SelectedIndex],2);
end;

procedure CountOfValue;
begin
v1.Value := Round(v2.Value*price[actions.SelectedIndex],2);
end;

begin
SetLength(Price,3);

b1.Click += CountOfLiters;
b2.Click += CountOfValue;

for var i := 0 to Price.Length-1 do
begin
price[i] := Random(100)+20;
end;
actions.Items.Add('"76" - '+price[0]+'р. за литр');
actions.Items.Add('"92" - '+price[1]+'р. за литр');
actions.Items.Add('"96" - '+price[2]+'р. за литр');
actions.SelectedIndex := 0;

end.
```

## 4. Нарисуйте все возможные деревья двоичного поиска для элементов 1, 2, 3, 4.

**АТД дерево** – ориентированный граф, элементы которого образуют иерархическую структуру с направлением связей "из одной вершины ко множеству".

**Бинарный поиск** – алгоритм, на входе получающий отсортированный список элементов, а на выходе возвращающий ту позицию, в которой был найден искомый элемент.
На примере чисел: с бинарным поиском, нужно просто загадывать число в середине списка и сключать половину списка.

> \- Цифры от одного до ста, поехали!
> \- 63? Много! (отсекается всё что больше 63, остаются [1 : 63])
> \-25? Мало! (отсекается всё что меньше 25, остаются [25 : 63])
> \-42? Да!

**Двоичное дерево поиска** или **бинарное дерево поиска**, это дерево, где значение левого потомка меньше значения родителя, а значение правого – больше. Оно наглядно визуализирует бинарный поиск. У каждого узла не больше двух прямых потомков.

> Бинарный поиск позволяет найти, в отсортированном списке из 4 миллиардов элементов, искомое значение не более чем за 32 попытки.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1w5ARS4ExjZyrE_J2y397kv99jxrQXfpy" style=" zoom: 70%;"><b><p style="text-align: center;">Разница в деревьях</p></b></p>

Для элементов `[1, 2, 3, 4]` можно составить $4!=24$ различных комбинаций. Двоичных деревьев меньше, так как не все комбинации подпадают под правило составления двоичных деревьев.

> Все деревья рисовать не нужно, надо сказать что их дохрена (меньше 24) и нарисовать хотя бы несколько.

Например, для этого ряда, есть такие двоичные деревья и их комбинации ключей:

> **Комбинация ключей** – порядок, в котором элементы заносились в двоичное дерево.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=178VnbLjfuy6w3mwqfeBGFkyKTkJENWKb" style=" zoom: 50%;"><b><p style="text-align: center;">Бинарные деревья для [1, 2, 3, 4]</p></b></p>
