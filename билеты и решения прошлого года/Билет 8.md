# Билет №8

## 1. Принципы объектно-ориентированного программирования. Дайте определение понятию “класс”, как правильно организовать доступ к полям класса?

**Объектно-ориентированное программирование** – концепция программирования, базирующаяся на использовании объектов.

> Если в структурной концепции главную роль играют **логика и понимание последовательности выполнения действия для достижения поставленной цели**, то в объектной концепции – **представление программы как системы взаимодействующих объектов**.

**Классом** в ООП понимается некая сущность, у которой можно смоделировать свойства и поведения. То есть, класс – некая идея сущности, своеобразный чертёж. Идею можно воплотить, и это воплощение будет называться **экземпляром** или **объектом**. У идеи есть некие характерные свойства – **атрибуты** или **поля**. Идее характерны некие способы взаимодействия – **методы**.

**Класс** – своеобразный чертёж объекта, позволяющий воплотить содержащуюся в нём идею в качестве экземпляра объекта.

**Класс** – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).

У класса есть специальные поля для отображения характеристик, присущих идее. Эти характеристики называются **атрибутами** или **полями**. Ожидаемо, что у атрибутов может быть возможность узнать их значение (*цвет яблока*) или изменить его (*перекрасить яблоко в синий*).

```python
class Apple:
    color = 'green'  # color - атрибут
```

Согласно концепциям ООП, пользователю (будь то разработчик или юзверь) опасно давать прямой доступ к характеристикам. Всего одна опечатка в коде изменяет операцию проверки равенства значения `==` в операцию присвоения `=` и наоборот.

Для выполнения операций получения или изменения значений, применяют специальные методы. **Геттеры** (`getАтрибут()`) для получения значения и **сеттеры** (`setАтрибут()`) для изменения значения. Отсутствие геттеров и сеттеров приводит к нарушению идеи инкапсуляции, а их присутствие позволяет безопасно выполнять эти действия, а также модифицировать выполнение по своему усмотрению.

> В геттер можно вшить проверку значения или принт прикольного сообщения, а в сеттер – проверку на допустимость значения или что-нибудь крутое.

В современном ООП принято выделять пять основных принципов (механизмов):

- **Абстракция**. Сущности и взаимодействия можно смоделировать (представить в качестве некой концепции) как классы и методы.

  > Яблок много разных бывает – красные, зелёные, вкусные и червистые. Но городские жители при слове "яблоко" знают о каком объекте речь – они знают идею "яблочности". Вот эта идея "яблочности" и есть абстракция, то есть набор всех таких характеристик объекта.

- **Инкапсуляция**. Свойство системы, позволяющее объединять данные и методы, работающие с ними, в классе, попутно скрыв детали реализации от пользователя.

  > Наполнить желудок едой можно напрямую, положив еду в желудок. Это опасно, поэтому прямой доступ к желудку закрыт. Наполнение желудка происходит через элемент интерфейса "рот", а обычному пользователю не обязательно знать, что между ртом и желудком есть другие элементы говнокода.

- **Наследование**. Свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

  > На заводе есть общая идея стола, прямо таки столистый стол (**родительский класс**). Но людям нужны разные столы, и поэтому на заводе есть другие коробки с идеями письменного, обеденного или журнального столика – все они являются наследником (**дочерним классом**) идеи столистого стола, но по своему изменяют её.
  >
  > Я получил власть, которая и не снилась моему отцу!

- **Полиморфизм**. Свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

  > Человек может /есть. Кошка может /есть. Но эти действия проходят по разному, и в обычном диалоге нам не нужно уточнять "а вот кошка есть с помощью такого комплекта зубов, языка интегральной формы X и атомного излучателя", мы просто понимаем "кошка ест, чо те непонятно".
  >
  > Аналогично с вождением велосипеда – умеешь ездить на одном, сможешь поехать и на другом.

- **Композиция**. Объекты зачастую формируются или состоят из других объектов.

  > Компьютер можно считать объектом. Компьютер содержит разные устройства – видеокарту, процессор, материнскую плату и так далее. Эти устройства тоже можно считать объектами.
  > Компьютер – объект, содержащий другие объекты.

## 2. Графы. Способы реализации.

**Граф** – математическая модель набора связей (отношений). То есть, это наглядное представление отношений между какими-либо объектами.

> В математическом виде, граф: (V, E, $\phi$). V – множество вершин, E – множество рёбер, $\phi$ – отношения между ними.

**Обход графа** – это переход от одной его вершины к другой в поисках свойств связей этих вершин. Связи (линии, соединяющие вершины) называются **рёбрами** графа, а вершины  – **узлами**. Если у узла нет потомков, он называется **листом**.

**Путь в графе** – некая последовательность вершин, каждая из которых соединена со следующей ребром. Численно путь характеризуется суммой весов этих рёбер.

**Ориентированный граф** – граф, рёбра которого имеют направление. То есть, из вершины 1 может быть дуга в вершину 2, но не всегда будет дуга из вершины 2 в вершину 1. В орграфе у ребра всегда есть начало и конец.

**Неориентированный граф** – граф, рёбра которого не имеют направления. То есть, если есть ребро между вершинами – из первой вершины всегда можно попасть во вторую, а из второй вершины – в первую.

Граф можно реализовать (представить) разными способами.

> **Матрицу инцидентности и список рёбер можно не указывать, это чисто доп. инфа.**

### 2.1 Матрица смежности

Граф хранится в формате двумерного массива (матрицы).  Размер зависит от количества вершин в графе.

**Матрица смежности графа** – это квадратная матрица, в которой каждый элемент принимает одно из двух значений: 0 или 1.

Число строк матрицы смежности равно числу столбцов и соответствует количеству вершин графа. 0 – соответствует отсутствию ребра, 1 – соответствует наличию ребра.

Когда из одной вершины в другую проход свободен (имеется ребро), в ячейку заносится 1, иначе – 0. Все элементы на главной диагонали равны 0 если граф не имеет петель.

> Базовые операции взаимодействия с графом становятся чрезвычайно эффективными с данной моделью реализации, но лишь когда число вершин графа невелико, а число рёбер – относительно большое.

Однако, матрица смежности требует $n^2$ объём памяти для $n$ вершин. Поэтому, на практике, годится только для маленьких графов и различных "классических" алгоритмов.

<p style="text-align: center;"><img src="https://bookflow.ru/wp-content/uploads/2020/03/Matritsa-smezhnosti-grafa-min-1024x321.png" style=" zoom: 60%;"><b><p style="text-align: center;">Матрица смежности графа</p></b></p>

### 2.2 Матрица инцидентности

Граф хранится в формате двумерного массива (матрицы).  Размер зависит от количества рёбер в графе.

**Матрица инцидентности (инциденции) графа** – это матрица, количество строк в которой соответствует числу вершин, а количество столбцов – числу рёбер. В ней указываются связи между инцидентными элементами графа (ребро и вершина).

> Инцидентность – когда вершина `b` является началом или концом ребра `c`. Например, если вершины `b` и `c` соединены ребром `t`, то они инцидентны ребру `t`.

В неориентированном графе если вершина инцидентна ребру то соответствующий элемент равен 1, в противном случае элемент равен 0.

В ориентированном графе если ребро выходит из вершины, то соответствующий элемент равен 1, если ребро входит в вершину, то соответствующий элемент равен -1, если ребро отсутствует, то элемент равен 0.

>Плюсы и минусы аналогичны матрице смежности.

<p style="text-align: center;"><img src="https://bookflow.ru/wp-content/uploads/2020/03/Matritsa-intsidentnosti-intsidentsii-grafa-min-1024x304.png" style=" zoom: 60%;"><b><p style="text-align: center;">Матрица инцидентности графа</p></b></p>

### 2.3 Список смежности

Граф можно представить в формате **списка смежности** – списка, который для каждой вершины содержит список смежных с ней вершин.

Списки инцидентности целесообразнее использовать когда:

- число вершин графа велико;
- число рёбер графа относительно невелико;
- во время действия алгоритма часто требуется модифицировать граф.

Быстродействие списка смежности падает с увеличением количества рёбер.

> На практике, списки смежности чаще всего используются в прикладных целях.

<p style="text-align: center;"><img src="https://bookflow.ru/wp-content/uploads/2020/03/Spisok-smezhnosti-intsidentnosti-min.png" style=" zoom: 60%;"><b><p style="text-align: center;">Список смежности</p></b></p>

### 2.4 Список рёбер

В **списке рёбер** в каждой строке записываются две смежные вершины и вес соединяющего их ребра (для взвешенного графа).

Популярная структура данных, всё аналогично списку смежности.

<p style="text-align: center;"><img src="https://bookflow.ru/wp-content/uploads/2020/03/Spisok-re-ber-min-905x420.png" style=" zoom: 60%;"><b><p style="text-align: center;">Список рёбер</p></b></p>

## 3. Задача

Составьте блок-схему и напишите программу, в которой принимается строка символов, состоящая из букв и пробелов (символы до пробела считаются словом). Слова отделяются друг от друга запятой и пробелом. Необходимо подсчитать количество слов.

****

#### **Пафосное решение:**

```python
import re
s = 'Найдя нужный вам код вы сможете определить, к какому региону относится тот или иной номер'
words = re.split('[, ]+', s)
print(f'Количество слов: {len(words)}')
```

#### **Решение 71-х:**

```python
s = input("Введите строку: ")
k=0
for i in s.split(' '):
    if i !="":
        k=k+1
print("Количество слов = ",k)
```

## 4. Задача

Создайте и заполните базу данных сотрудников предприятия связи, содержащую следующие таблицы: Сотрудники (табельный номер, ФИО, пол, номер\_должности, отдел, дата рождения, стаж, семейное положение, дети); Штатное расписание (номер\_должности, должность, оклад). Установите связь между таблицами.  Составьте запрос Зарплата, в котором зарплата сотрудников вычисляется по формуле оклад + премия. Премия зависит от стажа и составляет:

\- 50% от оклада, если стаж меньше или равен 3годам,
 \- 70% от оклада, если стаж больше 3, но меньше 8

\- 100% в остальных случаях.

Составьте и выполните запросы на выборку информации о тех сотрудниках, у которых зарплата больше средней, отсортировав по отделам, внутри отдела по фамилии: отдел, ФИО, должность, зарплата.

****

```sql
CREATE DATABASE IF NOT EXISTS связисты;  -- Создать БД если не существует
USE связисты;  -- Использовать БД

-- Создать таблицу "Расписание"
CREATE TABLE IF NOT EXISTS Расписание(
    код_должности INT PRIMARY KEY,
    должность VARCHAR(30),
     -- 12 - число знаков до ',', 2 - после
    оклад DECIMAL(12, 2)
);

INSERT INTO Расписание (код_должности, должность, оклад) 
    VALUES (1, 'доцент', 360.00);
INSERT INTO Расписание (код_должности, должность, оклад) 
    VALUES (2, 'магистрант', 215.00);
INSERT INTO Расписание (код_должности, должность, оклад) 
    VALUES (3, 'преподаватель', 310.00);

-- Создать таблицу "Сотрудники"
CREATE TABLE IF NOT EXISTS Сотрудники(
    табельный_номер INT PRIMARY KEY AUTO_INCREMENT, 
    фио VARCHAR(50),
    отдел VARCHAR(30),
    код_должности INT,
    пол VARCHAR(1),
    дата_рождения DATE,
    стаж INT,
    семья VARCHAR(1),
    дети INT,
    FOREIGN KEY (код_должности) REFERENCES Расписание (код_должности)
);

INSERT INTO Сотрудники (фио, отдел, код_должности, пол, дата_рождения, стаж, семья, дети) 
    VALUES ('Баранов П.Е.', 'ИСТ', 1, 'М', '1999-01-12', 13, 'Х', 1);
INSERT INTO Сотрудники (фио, отдел, код_должности, пол, дата_рождения, стаж, семья, дети) 
    VALUES ('Абрамова К.А.', 'МЭС', 1, 'Ж', '1989-04-26', 4, 'Х', 0);
INSERT INTO Сотрудники (фио, отдел, код_должности, пол, дата_рождения, стаж, семья, дети) 
    VALUES ('Семенов И.В.', 'МЭС', 2, 'М', '1979-05-13', 5, 'Р', 5);
INSERT INTO Сотрудники (фио, отдел, код_должности, пол, дата_рождения, стаж, семья, дети) 
    VALUES ('Ильиных Г.Р.', 'ИСТ', 3, 'Ж', '1985-03-05', 20, 'Б', 3);
```

>Составьте запрос Зарплата, в котором зарплата сотрудников вычисляется по формуле оклад+премия. Премия зависит от стажа и составляет:
>
>- 50% от оклада, если стаж меньше или равен 3 годам,
>- 70% от оклада, если стаж больше 3, но меньше 8
>- 100% в остальных случаях.

```sql
SELECT
    фио, должность, оклад + IF(стаж<=3, оклад*0.5, IF(стаж<=8, оклад*0.7, оклад)) AS Зарплата
FROM
    Сотрудники INNER JOIN Расписание USING (код_должности)
```

>Составьте и выполните запросы на выборку информации о тех сотрудниках, у которых зарплата больше средней, отсортировав по отделам, внутри отдела по фамилии: отдел, ФИО, должность, зарплата.

```sql
SELECT
    отдел, фио, должность,
    оклад + IF(стаж<=3, оклад*0.5, IF(стаж<=8, оклад*0.7, оклад)) AS Зарплата
FROM
    Сотрудники INNER JOIN Расписание USING (код_должности)
HAVING
    Зарплата > (SELECT
                    AVG(оклад + IF(стаж<=3, оклад*0.5, IF(стаж<=8, оклад*0.7, оклад))) AS ЗП
                FROM
                    Сотрудники INNER JOIN Расписание USING (код_должности))
ORDER BY
    отдел, фио
```
