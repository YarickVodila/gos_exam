# Билет №1

## 1. Сообщения и сигналы. Кодирование. Типы сигналов: аналоговый и дискретный.

**Информация** – *сведения* о каких-либо процессах, событиях, фактах или предметах, *уменьшающие неопределённость события*. Её форма представления является сообщением, служащем для передачи информации от источника к получателю.

**Сообщение** – форма представления информации.

**Сигнал** – материальный источник сообщений. Представляет собой процесс изменения во времени физического состояния какого-либо объекта, служащего для отображения, регистрации и передачи сообщений.

> Источником информации является физический объект, который формирует конкретное сообщение. Получатель этого сообщения и является получателем информации.

**Процесс передачи информации** заключается в том, что сооб­щения преобразуются в сигналы и по системе связи передаются получателю. Получатель, зная закон соответствия между сообще­ниями и сигналами, может извлечь содержащуюся в сообщении информацию. Для верного декодирования каждому сигналу должно соответствовать одно определенное сообщение.

Сигналы, в сетях и телекоммуникациях, могут быть дискретными и аналоговыми.

**Аналоговые сигналы** – непрерывные во времени сигналы, они определены во все моменты времени.

> При **аналоговом** представлении физическая величина принимает бесконечное множество значений, причем ее значения изменяются непрерывно.

**Дискретные сигналы** – сигналы, представленные последовательностью отсчётов, т.е. значениями сигналов в дискретные моменты времени.

> При **дискретном** представлении физическая величина принимает конечное множество значений, причем ее величина изменяется скачкообразно.

<p style="text-align: center;"><img src="https://cf2.ppt-online.org/files2/slide/a/akPF1KYbvS2uiCrAIH9p5qlWxdNVeQ6EDGsJnM/slide-17.jpg" style=" zoom: 60%;"><b><p style="text-align: center;">Сигналы</p></b></p>

Чтобы передать сигнал по сети, его нужно преобразовать в цифровую форму. **Цифровые сигналы** – это сигналы дискретные во времени (или в пространстве) и квантованные по уровню. Вычислительные процедуры в компьютере выполняются именно в цифровых сигналах. Процесс преобразования аналогового сигнала в форму, совместимую с цифровой системой обработки и передачи информации, называется **кодированием**.

Кодирование сообщений производится специальным устройством, которое называется **кодером** (кодирующим устройством) источника сообщения (датчика информации). В кодере кодовые комбинации представляются в виде опредёленных состояний накопительных эле­ментов.

Кодирование сигнала происходит в два этапа:

1. **Дискретизация сигнала** (если аналоговый).
   Сигнал представляется в виде последовательности значений, взятых в дискретные моменты времени.

   > Разделение на временные промежутки.

2. **Квантование сигнала**.
   Вся область значений сигнала разбивается на уровни, каждому из которы присваивается некоторое число. Отсчёты сигнала сравниваются с уровнями квантования и в качестве сигнала выбирается это число.

   > Выборка примерного значения.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=14ZSAm5EUWAhxx31XS05rJUXB7rDmqiIT" style=" zoom: 50%;"><b><p style="text-align: center;">Дискретизация и квантование</p></b></p>

## 2. Организация параллельной работы устройств ввода-вывода и процессора.

**Назначение системы ввода-вывода** – обеспечение связи ядра ЭВМ с внешней средой, посредством периферийных устройств.

У каждого устройства ввода-вывода вычислительной системы (диск, принтер, мышь) есть специальный блок управления – **контроллер**. Он взаимодействует с **драйвером** – системным программным модулем для управления контроллером.

> Взаимодействие контроллера и драйвера позволяет устройству *некоторое время* выполнять свои операции автономно, без взаимодействия с процессором компьютера.
>
> Срок автономности зависит от объёма выводимой информации и степени интеллектуальности контроллера.

Однако, контроллеры даже для самых простых функций работают сравнительно медленно, их скорость работы существенно ниже скорости работы процессора. То есть, процессы, происходящие в контроллерах, протекают в периоды между выдачами команд *независимо от ОС*.

Подсистема ввода-вывода нужна для выполнения следующих задач:

- В масштабе реального времени (так как в нём работают внешние устройства) спланировать запуск и приостановку разнообразных драйверов.

  > Так можно обеспечить приемлемое время реакции каждого драйвера на независимые события контроллера.

- Минимизировать загрузку процессора обработкой задач ввода-вывода, оставив как можно больше процессорного времени на выполнение пользовательских задач.

Существует три основных технологии организации подсистемы ввода-вывода:

1. **Программируемый ввод-вывод с режимом опроса готовности**.
   Когда процессор встречает команду ввода-вывода (В-В), то он выполняет её и передаёт информацию соответствующим контроллерам. Процесс переводится в состояние ожидания завершения операции В-В, а процессор ждёт сигнал готовности. Этот сигнал отправляется контроллером после того как устройство выполняет команду.

   > Метод лёгкий, но режим ожидания жрёт много процессорного времени.

2. **Режим обмена с прерыванием**.
   После выдачи очередной команды по управлению В-В, процесс прерывается и процессор может дальше заниматься своими грязными делишками. Устройство В-В выполняет свою задачу асинхронно, и через определённое время должно подать процессору сигнал "я сделаль". У проца ведётся отсчёт времени, если устройство не ответило – ОС считает, что связь с ним потеряна и выдаёт сообщение.

   > Метод сложнее в реализации, но существенно оптимизирует процессорное время.

3. **Прямой доступ к памяти**.
   В-В осуществляет специальное устройство (модуль), дублирующее функции процессора по В-В. Когда проц должен повзаимодействовать с устройством В-В, он перенаправляет запрос на этот модуль, который осуществляет **режим обмена с прерываниями** и после операции передаёт инфу процу. То есть, проц работает с В-В только в начале и в конце выполнения операции.

   > Используется редко, можно забыть про этот метод.

## 3. Преобразуйте выражение ((a+b)+c\*(d+e)+f)\*(g+h) в префиксную форму.

Алгебраическое выражение можно записать в трёх формах: инфиксной, префиксной и постфиксной.

**Инфиксная форма**. Выражение, где операторы находятся **между** операторами.

> $2+2=4$

**Префиксная форма**. Выражение, где операторы находятся **перед** операторами.

> $+2\;2=4$

Исходное выражение записано в инфиксной форме.

>$((A+B)+C*(D+E)+F)*(G+H)$

Для наглядности, сначала нужно построить дерево для исходной формы:

1. Подписываем над выражением порядок операций;
2. Корнем дерева делаем операцию №1;
3. Фигачим в качестве узлов подписанные операторы, но в обратном порядке. К операторам добавляем потомков – аргументы операции. Если вместо аргумента идёт операция, фигачим её оператор и продолжаем пункт №3.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1n6WrJgQjjI4qT6XJnGcRUxvH1-QSbxgZ" style=" zoom: 40%;"><b><p style="text-align: center;">Префиксное дэрево</p></b></p>

Префиксная форма составляется через DFS (обход в глубину).

**Метод обхода графа в глубину** или `DFS` – обход графа "как можно глубже". Этот метод идёт по такому условию: если у элемента остались непросмотренные соседи, обход переходит на неё. Обход ведётся для каждой вершины, то есть можно помечать пройденность вершин (к примеру, как дополнительный массив пройденных вершин).

> Мыш кродётся по лабиринту и ищет еду.

**DFS двигается по граням туда и обратно, реализуется стеком.**

## 4. Задача

Разработайте программу «Телефонная книга», позволяющую отображать записи в телефонной книге, выполнять их редактирование (изменение выбранной записи), добавление новой записи, удаление выбранной записи, осуществлять поиск по критериям, сохранять содержимое в текстовом файле с заданным именем и загружать данные из этого текстового файла.

****

#### ~~Пафосное~~ Тупое решение

```python
# Функция для считывания файла в словарь
def file_to_dict(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        data = f.readlines()
        phones = {}
        for record in data:
            info = record.strip().split(': ')
            phone, name = info[0], info[1]
            if not phone in phones:
                phones[phone] = name
        return phones

# Функция для записи словаря в файл
def dict_to_file(phones, filename):
    with open(filename, 'w', encoding='utf-8') as f:
        for phone, name in phones.items():
            f.write(f'{phone}: {name}\n')

phones_file = 'Телефоны.txt'
phonebook = file_to_dict(phones_file)
while True:
    command = int(input("""\nМеню:
1. Вывод телефонной книги
2. Поиск контакта
3. Добавление контакта
4. Переименование контакта
5. Удаление контакта
0. Выход из программы
Введите действие:"""))
    print()
    if command == 1:
        print('Вывод телефонной книги:')
        for number, name in phonebook.items():
            print(f'Номер: {number}, название: {name}')
    elif command == 2:
        take = int(input("""Поиск контакта.
Контакт нужно найти по номеру (1) или по названию (2)?"""))
        if take == 1:
            number = input('Номер контакта:')
            if number in phonebook:
                name = phonebook[number]
                print(f'Номер: {number}, название: {name}')
            else:
                print(f'Контакт не найден!')
        elif take == 2:
            name = input('Название контакта:')
            if name in phonebook.values():
                number = list(phonebook.keys())[list(phonebook.values()).index(name)]
                print(f'Номер: {number}, название: {name}')
            else:
                print(f'Контакт не найден!')
        else:
            break
    elif command == 3:
        print('Добавление контакта:')
        number = input('Номер контакта:')
        name = input('Название контакта:')
        phonebook[number] = name
        print(f'Контакт добавлен!')
    elif command == 4:
        print('Переименование контакта:')
        number = input('Номер контакта:')
        if number in phonebook:
            name = phonebook[number]
            print(f'Номер: {number}, название: {name}')
            name = input('Введите новое название контакта')
            phonebook[number] = name
            print(f'Контакт переименован!')
        else:
            print(f'Контакт не найден!')
    elif command == 5:
        print('Удаление контакта:')
        number = input('Номер контакта:')
        if number in phonebook:
            print(f'Номер: {number}, название: {name}')
            del(phonebook[number])
            print(f'Контакт удалён!')
        else:
            print(f'Контакт не найден!')
    else:
        break
    
    dict_to_file(phonebook, phones_file)
```

#### Реально крутое решение с интерфейсом на Flask (веб-морда)

```python
import sqlite3
import flask


conn = sqlite3.connect("phonebook.db")
cur = conn.cursor()
cur.execute('''CREATE TABLE IF NOT EXISTS phones (id INTEGER PRIMARY KEY, phone INTEGER, name TEXT);''')
conn.commit()
cur.close()
conn.close()
app = flask.Flask("Phonebook")


@app.route("/")
def index():
    resp = '<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Телефонная книга</title></head><body>'
    conn = sqlite3.connect("phonebook.db")
    cur = conn.cursor()
    cur.execute('''SELECT * FROM phones;''')
    phones = cur.fetchall()
    if len(phones) == 0:
        resp += 'В базе пока нет номеров'
    else:
        resp += '<table border="1" width="100%" cellpadding="5"><tr><th>ID</th><th>Телефон</th><th>Абонент</th><th>Редактировать</th><th>Удалить</th></tr>'
        for i in phones:
            redlink = '<a href="/edit?id=%s">Редактировать</a>' % i[0]
            dellink = '<a href="/delete?id=%s">Удалить</a>' % i[0]
            resp += '<tr><th>%s</th><th>%s</th><th>%s</th><th>%s</th><th>%s</th></tr>' % (i[0], i[1], i[2], redlink, dellink)
        resp += '</table>'
    resp += '<p><a href="/find">Поиск</a></p><p><a href="/add">Добавить номер</a></p></body></html>'
    conn.close()
    return resp


@app.route("/add", methods = ['POST', 'GET'])
def add():
    if flask.request.method == "POST":
        conn = sqlite3.connect("phonebook.db")
        cur = conn.cursor()
        phone = flask.request.form["phone"]
        name = flask.request.form["name"]
        cur.execute('''INSERT INTO phones (phone, name) VALUES (%s, "%s");''' % (phone, name))
        conn.commit()
        conn.close()
        return flask.redirect("/")
    else:
        resp = '<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Телефонная книга</title></head><body>'
        resp += '<form action="/add" method="post"><p>Телефон:</p><p><input type = "number" name = "phone" /></p>' 
        resp += '<p>Абонент:</p><p><input type = "text" name = "name" /></p>'
        resp += '<p><input type = "submit" value = "Добавить" /></p>'
        resp += '<a href="/">Назад к списку</a></body></html>'
        return resp


@app.route("/edit", methods = ['POST', 'GET'])
def edit():
    conn = sqlite3.connect("phonebook.db")
    cur = conn.cursor()
    if flask.request.method == "POST":
        id = flask.request.args.get("id")
        phone = flask.request.form["phone"]
        name = flask.request.form["name"]
        cur.execute('''UPDATE phones SET phone = %s, name="%s" WHERE id = "%s";''' % (phone, name, id))
        conn.commit()
        conn.close()
        return flask.redirect("/")
    else:
        id = flask.request.args.get("id")
        cur.execute('''SELECT * FROM phones WHERE id="%s"''' % id)
        phone = cur.fetchone()
        resp = '<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Телефонная книга</title></head><body>'
        resp += '<form action="/edit?id=%s" method="post"><p>Телефон:</p><p><input type = "number" name = "phone" value="%s" /></p>' % (phone[0], phone[1])
        resp += '<p>Абонент:</p><p><input type = "text" name = "name" value="%s" /></p>' % phone[2]
        resp += '<p><input type = "submit" value = "Изменить" /></p>'
        resp += '<a href="/">Назад к списку</a></body></html>'
        conn.close()
        return resp
    

@app.route("/delete")
def delete():
    conn = sqlite3.connect("phonebook.db")
    cur = conn.cursor()
    id = flask.request.args.get("id")
    cur.execute('''DELETE FROM phones WHERE id="%s";''' % id)
    conn.commit()
    conn.close()
    return flask.redirect("/")


@app.route("/find", methods = ['POST', 'GET'])
def find():
    conn = sqlite3.connect("phonebook.db")
    cur = conn.cursor()
    resp = '<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Телефонная книга</title></head><body>'
    if flask.request.method == "POST":
        phone = flask.request.form["phone"]
        name = flask.request.form["name"]
        cur.execute('''SELECT * FROM phones WHERE phone LIKE "%''' + phone + '''%" AND name LIKE "%''' + name + '''%";''')
        phones = cur.fetchall()
        if len(phones) == 0:
            resp += 'Результатов не обнаружено'
        else:
            resp += '<table border="1" width="100%" cellpadding="5"><tr><th>ID</th><th>Телефон</th><th>Абонент</th><th>Редактировать</th><th>Удалить</th></tr>'
            for i in phones:
                redlink = '<a href="/edit?id=%s">Редактировать</a>' % i[0]
                dellink = '<a href="/delete?id=%s">Удалить</a>' % i[0]
                resp += '<tr><th>%s</th><th>%s</th><th>%s</th><th>%s</th><th>%s</th></tr>' % (i[0], i[1], i[2], redlink, dellink)
        resp += '</table>'    
    resp += '<form action="/find" method="post"><p>Поиск по номеру:</p><p><input type = "number" name = "phone" /></p>' 
    resp += '<p>Поиск по имени:</p><p><input type = "text" name = "name" /></p>'
    resp += '<p><input type = "submit" value = "Искать" /></p>'
    resp += '<a href="/">Назад к списку</a></body></html>'
    conn.close()
    return resp


app.run("0.0.0.0", 8080)
```
