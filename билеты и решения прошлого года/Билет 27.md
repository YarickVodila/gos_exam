# Билет №27

## 1. Назначение и функции маршрутизаторов, методы и протоколы обмена зонами.

**Маршрутизатор** – устройство, работающее на сетевом уровне модели OSI, и обеспечивающее поиск пути от источника до получателя. Оно использует одну или более метрик для определения оптимального пути передачи сетевого трафика на основании информации сетевого уровня.

> Маршрутизатор умеет очень гибко управлять трафиком, но обладает сравнительно низкой производительностью, L3-коммутатор же обладает высокой производительностью, но практически ничего не умеет.

Функции маршрутизатора:

- Чтение заголовков пакетов сетевых протоколов;
- Построение таблицы маршрутизации на основе протоколов маршрутизации;
- Определении на еë основе маршрута;
- Буферизация;
- Фрагментация;
- Фильтрация поступающих пакетов;
- Поддержка сетевых интерфейсов.

Сеть в общем случае рассматривается как совокупность нескольких сетей и называется **составной сетью** или **интерсетью** (internetwork или internet).

Сети, входящие в составную сеть, называются **подсетями** (subnet) или просто сетями.

Маршруты внутри сетей хранятся в специальных маршрутных таблицах – **таблицах маршрутизации**. Их можно составлять статически (вручную) или динамически (с помощью специальных протоколов).

> **Таблица маршрутизации** – электронная таблица (файл) или база данных, хранящаяся на маршрутизаторе или сетевом компьютере, которая описывает соответствие между адресами назначения и интерфейсами, через которые следует отправить пакет данных до следующего маршрутизатора.
>
> Таблица маршрутизации является простейшей формой правил маршрутизации.

В динамической маршрутизации есть:

- **Протоколы маршрутизации (Routing Protocols).**
  Протоколы, с помощью которых маршрутизаторы обмениваются маршрутной информацией и строят топологию.
- **Маршрутизируемые протоколы (Routed Protocols).**
  Протоколы, для которых строится маршрутная топология (например, IPv4 и IPv6).

> Использование протоколов маршрутизации позволяет освободить человека от рутинного заполнения маршрутов, а систему – от человеческого фактора, дополнительно повышая её отказоустойчивость на основе отслеживания доступности сегментов сети.

Протоколы маршрутизации можно разделить на внешние (**EGP** или **Eterior Gateway Protocol**) и внутренние (**IGP** или **Interior Gateway Protocol**). Внешние протоколы используются для соединения автономных сетей между собой, а внутренние – для соединения узлов внутри автономной сети.

Среди протоколов машрутизации особо выделяются три самых известных:

1. **Внутренний протокол маршрутизации RIP – Routing Information Protocol.**
   **Протокол маршрутной информации.**
   Так как это внутренний протокол маршрутизации, то он нужен для маршрутизации в рамках одной локальной сети.
   Является дистанционно-векторным, то есть работает по принципу "рассылай таблицу маршрутизации ближним своим". Главной характеристикой служит **метрика** – числовой показатель, задающий предпочтительность маршрута (интуитивно сравнивается с расстоянием). В RIP метрикой служат жопы – количество маршрутизаторов до цели.

   RIP был первым протоколом маршрутизации и сейчас практически не используется. Его главная задача – вовремя обновлять все таблицы маршрутов в сети, посылая регулярные сообщения об их обновлении.

   **Плюсы протокола RIP:**

   - Простой алгоритм;
   - Его знают почти все сливки сетевого общества (хотя по возрасту они уже сыр).

   **Минусы протокола RIP:**

   - Не работает с адресами подсетей;
   - После сбоя связи в маршрутизаторе, требуется много времени для восстановления связи;
   - Очень легко образуются петли и зацикливания;
   - Не поддерживает больше 16-и маршрутизаторов в сети (то есть, 15 хопов);
   - Метрика учитывает только количество хопов, но не пропускную способность сети;
   - Из-за медленного распространения маршрутной информации по сети, система не поспевает за изменеиями;
   - Не поддерживает хранение резервных маршрутов.

   Часть этих минусов была исправлена в более новой версии RIPv2, но к делу это не относится.

2. **Внутренний протокол маршрутизации OSPF – Open Shortest Path First.** 
   **Открытый алгоритм предпочтительного выбора кратчайшего маршрута.**
   Тип протокола OSPF основан на технологии отслеживания состояния канала: при выборе маршрута важно не количество узлов, а скорость канала.

   Базируется на алгоритме построения дерева кратчайших путей (SPF): для каждого маршрутизатора, граф сети преобразуется в дерево кратчайших путей, где корень – текущий маршрутизатор, а потомки – варианты маршрутизаторов, для которых кратчайший путь может быть найден.

   **Принцип работы OSPF:**

   1. После включения маршрутизаторов, OSPF ищет непосредственно подключенных соседей и коннектится с ними.
   2. После коннекта, соседи обмениваются друг с другом информацией о подключенных и доступных им сетях – они строят карту сети (топологию сети). Данная карта одинакова на всех маршрутизаторах.
   3. На основе полученной информации, для каждого маршрутизатора запускается SPF алгоритм, рассчитывающий оптимальный маршрут к каждой сети. Данный процесс называеться конвергенцией и происходит очень быстро.

   **Плюсы OSPF:**

   - Нет ограничений на размер сети;
   - В сторону одного узла может быть несколько маршрутов;
   - Поддерживает аутентификацию;
   - Высокая скорость составления маршрута.

   **Минусы OSPF:**

   - Вытеснил RIP, олды недовольны;
   - Требует глубоких знаний о сложных сетях – на коленке уже не развернуть сеть из зиккуратов;
   - В сети есть только одна таблица машрутной информации – её хранит каждый маршрутизатор, но не как ссылку на некий объект, а как цельный массив данных. То есть, увеличивается объём необходимой памяти.

   > SPF протоколы не рассылают периодические обновления, как это делают векторные алгоритмы. Вместо этого они рассылают обновления каждые 30 минут, причём не всю базу данных, а лишь определённую часть, тем самым облегчая загрузку сети.
   >
   > Если какой-нибудь интерфейс или маршрутизатор отключится, то будет немедленно сгенерировано обновление и все маршрутизаторы сразу же обновят свои таблицы маршрутизации.

3. **Внеший протокол маршрутизации BGP – Border Gateway Protocol.** 
   **Пограничный межсетевой протокол.**
   Так как это внешний протокол маршрутизации, то он нужен для маршрутизации в рамках интернета. Является протоколом прикладного уровня.

   Маршрутизаторы, использующие протокол BGP, обмениваются информацией о маршрутизации и доступности сетей. То есть, BGP призван обеспечивать передачу маршрутов между различными сетями. Любая контора, будь то яндекс или пятёрочка, используют BGP для подключения своих дата-центров к интернету.

   **BGP является специальным протоколом:**

   - [x] Легко масштабируется;
   - [x] Имеет защиту от образования петель;
   - [x] Включает систему управления приоритетами маршрутов;
   - [x] Обладает высокой стабильностью;
   - [x] Так как должен связывать автономные сети, то должен "понимать" чем эти автономные сети являются и как их различать;
   - [x] Является дистанционно-векторным, так как маршрутизатор должен выбирать маршрут до сети из нескольких предложенных, а не просчитывать весь интернет (а цепляются сети в интернет как раз через BGP).
   - [ ] Принцип работы объясняется сетевиками с помощью довольно сложных концепций;
   - [ ] Принцип работы я описывать здесь не буду.

   **У данного протокола есть также ряд особенностей:**

   - В качестве транспортного протокола, BGP использует протокол TCP;
   - BGP использует метрики не для определения петель, а для управления сетевыми политиками (правилами сети), которые используются маршрутизаторами во время выбора пути;
   - BGP не использует специальные системы обнаружения соседей – они добавляются и настраиваются вручную;
   - BGP безразлична топология автономных сетей – ответственность за маршрутизацию внутри неё должны нести внутренние протоколы маршрутизации.

## 2. Особенности файловых систем различных операционных систем. Проблемы совместимости и их решение.

**Файл** – именованная область внешней памяти, в которую можно записывать и из которой можно считывать данные.

**Файловая система** (ФС) – часть ОС, назначение которой состоит в предоставлении пользователю интерфейса для работы с данными, хранящимися во внешней памяти.

**Служебная структура** – структурированная область, содержащая общую информацию о ФС, свободных блоках данных (кластерах) и размещении файлов в кластерах.

> ФС играет роль промежуточного слоя, экранирующего все сложности физической организации долговременного хранилища данных, и создающего для программ более простую логическую модель этого хранилища, а также предоставляя им набор удобных в использовании команд для манипулирования файлами.

С точки зрения архитектуры, ФС представляет собой набор служебных структур, предназначенных для управления файлами на диске и определяющих форму их хранения. Каждый набор структур размещён в разделе того диска, к которому он относится.

Служебные структуры базируются на **индексных дескрипторах** – они хранят метаданные об объектах ФС, вроде владельца файла и его группы доступа.

Различные ОС используют различные ФС, причём служебные структуры в разных ФС могут кардинально различаться. То есть, в прямом виде они не совместимы. Однако, поддержка разных ФС может реализовываться либо на уровне ядра ОС через различные модули-драйвера, либо на уровне прикладного ПО.

> Например, ОС Windows может считывать ФС `ext4` ОС Linux только через специальные утилиты, вроде Midnight Commander.

У каждой ОС есть свой популярный набор файловых систем: Windows (FAT32, NTFS, exFAT), Linux (ext), MAC (HFS):

- `FAT`. ФС, в основе которой лежит **файловая таблица** – она хранит в себе записи об имеющихся файлах, времени их создания и последнего доступа к ним. Версии FAT отличаются только длиной записи блока.
  В FAT нет журналирования, поэтому чтение/запись идёт быстрее (меньше времени тратится на логи). Она быстро работает с малыми и средними каталогами, но с фрагментированным диском и большими каталогами (по количеству файлов) – очень медленно.

  > FAT32 до сих пор используется для небольших флешек и старого оборудования, хоть и не поддерживает файлы размером больше 4 Гб.
  >
  > FAT64 известна как exFAT, она часто применяется для ёмких флешек и карт памяти. Может работать не только с Windows, но и с MAC.

- `NTFS`. Журналируемая (с продвинутым логированием) ФС. Как и FAT, основывается на таблицах, однако в NTFS они более совершенные и называются MFT. Строкам MFT соответствуют файлы раздела, а столбцы – атрибуты файлов (дата создания, размер, права доступа и прочее).
  NTFS рационально использует место на носителе, она надёжна и быстро работает с большими файлами. Однако, не поддерживает системы ниже Windows NT и имеет ряд ограничений при работе с другими ОС (MAC и Linux читают NTFS, но не могут записывать).

  > NTFS – родная система для современной винды.

- `ext`. Построена на ядре Linux, журналируемость опциональна. Основной элемент ФС – **суперблок**, который содержит общую информацию о ФС и находится в 1024 байтах от начала раздела. Работоспособность ФС напрямую зависит от целостности суперблока.
  Низкий уровень фрагментации, активно улучшается разработчиками и поддерживается многими дистрибутивами Linux. Однако, не поддерживается проверка контрольных сумм для данных, а производительность падает в разделах с размером около 100 Тб.
  В Windows и MAC работает только через специальное ПО и драйверы.

  > Одна из самых быстрых ФС на запись и чтение данных, но низкая отказоустойчивость: в домашних условиях, с NTFS восстановить данные гораздо вероятнее чем с ext4.

- `ZFS`. ФС, объединённая с менеджером логических томов. Поддерживает базовый функционал ФС и продвинутые возможности, такие как хранение файлов на нескольких устройствах, шифрование в реальном времени и создание снапшотов (копия файлов и каталогов ФС на определённый момент времени). Поддерживает огромный размер файлов, разделов и самой ФС.
  Из недостатков, не в полной мере поддерживается всеми современными ОС, и на многих аппаратных сборках лагает как дедушкина перфокарта.

  > Новомодное чудо заморское.

## 3. К каким конструкциям Java применим модификатор static?

**Объектно-ориентированное программирование** – концепция программирования, базирующаяся на использовании объектов.

> Если в структурной концепции главную роль играют **логика и понимание последовательности выполнения действия для достижения поставленной цели**, то в объектной концепции – **представление программы как системы взаимодействующих объектов**.

**Классом** в ООП понимается некая сущность, у которой можно смоделировать свойства и поведения. То есть, класс – некая идея сущности, своеобразный чертёж. Идею можно воплотить, и это воплощение будет называться **экземпляром** или **объектом**. У идеи есть некие характерные свойства – **атрибуты** или **поля**. Идее характерны некие способы взаимодействия – **методы**.

**Класс** – своеобразный чертёж объекта, позволяющий воплотить содержащуюся в нём идею в качестве экземпляра объекта.

**Класс** – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).

> `static` – своеобразный поводок к исходному классу, общий для всех его экземпляров.

Фича статического метода в том, что обычные методы у класса вызвать нельзя – только у его конкретного объекта. А вот статические методы позволяют для какого-нибудь класса `Треугольник` определить площадь по заданной формуле, например как `Треугольник.площадь(1, 2, 3)`.

Модификатор `static` обозначает некую реализацию поводка к классу, общую для всех экземпляров класса.

Может применяться к следующим конструкциям:

- **Поле**. Если к переменной, уровня класса, добавить модификатор `static`, то значение переменной будет привязываться к классу, а не к экземпляру (значение общее для класса);
- **Блок инициализации**. Это штука для инициализации внутренних переменных (аналог конструктора, но выполняется перед инициализацией класса или перед созданием экземпляра через конструктор). Если `static`, то относится ко всему классу, если нет – свой для каждого экземпляра;
- **Метод**. Если метод объявить статическим, то он может взаимодействовать только со статическими переменными или методами. Также привязан к классу, а не к объекту.
- **Внутренний класс**. Это класс, который находится внутри другого класса. Если объявлен статическим, то его экземпляр будет общим для всего класса.

## 4. Задача

Напишите программу тестирования. Тест состоит из 10 вопросов, на которые предполагаются ответы в виде чисел. Вопросы выпадают случайным образом. Оценка выставляется автоматически в зависимости от числа правильных ответов (10-9 правильных ответов – 5; 8-7 правильных ответов – 4 и т.д.).

****

#### Пафосное решение:

```python
import numpy as np

def generate_numbers(count, num_start, num_end):
    mul1 = np.random.randint(num_start, num_end, size=count)
    mul2 = np.random.randint(num_start, num_end, size=count)
    for i in range(count):
        yield mul1[i], mul2[i]

def quiz(count, start_number, end_number):
    correct_answers = 0
    for num1, num2 in generate_numbers(count, start_number, end_number):
        res = input(f'{num1} * {num2} =')
        if res.isdigit() and num1*num2 == int(res):
            print('Правильно!')
            correct_answers += 1
        else:
            print('Неверно!')
    
    if correct_answers == 10:
        return 'Отлично'
    elif correct_answers in [9, 8]:
        return 'Хорошо'
    elif correct_answers in [7, 6]:
        return 'Удовлетворительно'
    else:
        return 'Плохо'

TOTAL = 10
start_number, end_number = 1, 13  # Диапазон чисел в примерах
result = quiz(TOTAL, start_number, end_number)
print(result)
```

#### Решение 71-х:

```python
import random

i=0
k=0
for i in range(10):
    a = random.randint(1, 9)
    b = random.randint(1, 9)
    print(a," x ",b )
    result = int(input())
    if ((a*b) == result):
        k = k+2;
if (k == 10):
    print("Отлично")
elif (8 <= k <= 9):
    print ("Хорошо")
elif (6 <= k <= 7):
    print("Удовлетворительно")
else:
    print("Плохо")
```