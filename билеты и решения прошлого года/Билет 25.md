# Билет №25

## 1. Формы языка SQL, их назначение. Составные части языка SQL.

**База данных** – упорядоченный набор структурированной информации или данных, которые обычно хранятся в электронном виде в компьютерной системе.

**База данных** – имеющая название совокупность данных, которая отражает состояние объектов и их отношений в рассматриваемой предметной области.

Базы данных бывают разными: **иерархическими** (древовидная структура), **сетевыми** (графовидная структура) и **реляционными** (табличное представление данных).

**SQL** – это язык структурированных запросов (Structured Query Language), позволяющий хранить, манипулировать и извлекать данные из реляционных баз данных. Он предназначен только для взаимодействия с базами данных.

SQL реализуется в следующих формах:

- **Интерактивный SQL** или **автономный SQL**. Позволяет пользователю выполнять SQL-операторы в интерактивном режиме.

  > Пользователь может непосредственно работать с SQL через консольку и файлы.

- **Статический SQL**. Позволяет реализовывать встроенный SQL, так как операторы данной формы определены уже в момент компиляции программы.

  >Штука для создания библиотек работы с SQL в разных языках программирования.

- **Динамический SQL**. Позволяет формировать операторы SQL во время выполнения программы.

  >Динамическая генерация и выполнение операторов в ходе работы приложения.

- **Встроенный SQL**. Позволяет включать операторы SQL в код программы на другом языке программирования.

  >Библиотека SQLAlchemy в Python. 

Условно, в SQL можно выделить две составные части:

1. **DDL** или **Data Definition Language**, язык определения данных.
   К этой части языка относятся разнообразные операторы создания (`CREATE`), модификации (`ALTER`) и удаления (`DELETE`) объектов, управление правами пользователей.
2. **DML** или **Data Manipulation Language**, язык манипулирования данными.
   К этой части языка относятся различные операторы выборки (`SELECT`), добавления (`INSERT`), модификации (`UPDATE`) и удаления (`DELETE`) данных из базы данных.

## 2. Графы. Построение минимального остовного дерева.

**Граф** – математическая модель набора связей (отношений). То есть, это наглядное представление отношений между какими-либо объектами.

> В математическом виде, граф: (V, E, $\phi$). V – множество вершин, E – множество рёбер, $\phi$ – отношения между ними.

**Обход графа** – это переход от одной его вершины к другой в поисках свойств связей этих вершин. Связи (линии, соединяющие вершины) называются **рёбрами** графа, а вершины  – **узлами**. Если у узла нет потомков, он называется **листом**.

**Путь в графе** – некая последовательность вершин, каждая из которых соединена со следующей ребром. Численно путь характеризуется суммой весов этих рёбер.

**Ориентированный граф** – граф, рёбра которого имеют направление. То есть, из вершины 1 может быть дуга в вершину 2, но не всегда будет дуга из вершины 2 в вершину 1. В орграфе у ребра всегда есть начало и конец.

**Неориентированный граф** – граф, рёбра которого не имеют направления. То есть, если есть ребро между вершинами – из первой вершины всегда можно попасть во вторую, а из второй вершины – в первую.

Задача о минимальных остовах: дан неориентированный граф, нужно найти такое его дерево, которое бы соединяло все его вершины и при этом обладало наименьшим весом рёбер (суммой весов рёбер).

> Нужно представить исходный граф без рёбер и как-то соединить все вершины между собой, чтобы из любой вершины можно было попасть в другую, но петель не было, а у графа был бы минимальный вес рёбер.

**Минимально покрывающее дерево** – дерево минимального веса в графе.

> Дано дерево – нужно найти скелет.

Построить такой скелет можно через разнообразные алгоритмы, самыми популярными из которых являются алгоритм Прима и алгоритм Крускала.

### Алгоритм Прима

Простейший алгоритм построения минимального остовного дерева.

- Изначально остов – одна произвольная вершина.
- Пока минимальный остов не найден, выбирается ребро минимального веса, исходящее из какой-нибудь вершины текущего остова в вершину, которую мы ещё не добавили. Добавляем это ребро в остов и продолжаем выборку, пока остов не будет найден.

> На каждом шаге пытаемся найти оптимальный вариант.

Алгоритм Прима быстрее работает на графах, где дофига рёбер (примерно равно $n^2$). Применяется редко.

<p style="text-align: center;"><img src="https://evileg.com/media/users/mafulechka/photos/photo_qKWiIiY.jpg" style=" zoom: 70%;"><b><p style="text-align: center;">Алгоритм Прима</p></b></p>

### Алгоритм Крускала

Суть в сортировке рёбер и добавлении их в остов в порядке возрастания весов. Если ребро соединяет две уже соединённые вершины, оно не добавляется.

> Также, на каждом шаге пытаемся найти оптимальный вариант.

Алгоритм Крускала быстрее работает на графах, где количество рёбер примерно равно количеству вершин. Применяется часто.

<p style="text-align: center;"><img src="https://evileg.com/media/users/mafulechka/photos/photo_DeWi7Qj.jpg" style=" zoom: 70%;"><b><p style="text-align: center;">Алгоритм Крускала</p></b></p>

## 3. Какие особенности инициализации final переменных? Приведите примеры.

Модификатор `final` – специальное ключевое слово, указывающее на невозможность дальнейшего изменения объекта.

> Если объект является ссылкой на другой объект, то `final` просто запретит изменение ссылки, но у того другого объекта можно будет поменять значение.

Если **переменную** объявить как `final` , то после присвоения её не изменить. В той же Java нет отдельного ключевого слова для констант, обычно их объявляют как `static final`.

Главная особенность инициализации `final` переменных заключается в их взаимодействии с объектами ссылочного типа, вроде массивов.

Так, если присвоить подобной переменной массив, то по факту она будет хранить ссылку на объект массива в памяти. Присвоить переменной другой массив будет нельзя, но в самом массиве вполне спокойно можно поменять элементы даже по прямому обращению через `final` переменную.

Комбинация ключевых слов `static final` используется для объявления констант – в Java не поддерживается ключевое слово `const`, встречающееся во многих других языках. Имена констант принято записывать в верхнем регистре, разделяя слова подчёркиванием.

Сами же переменные `static final` могут быть инициализированы во время объявления, или же в `static` блоке (аналог конструктора, но вызывается в момент инициализации самого класса, а не для каждого из его экземпляров).

## 4. Задача

Разработайте программу «Движение фигуры». В программе организовать движение фигуры вдоль линии окружности, с возможностью изменения значений радиуса и положения центра вращения (можно использовать любой язык программирования).

****

```python
import tkinter as tk
from math import sin, cos, radians

# Константы
X, Y = 600, 600  # Ширина и высота окна
R = 200  # Радиус орбиты
POINT_X, POINT_Y = X/2, Y/2 # Центр орбиты
DELAY = 30  # Интервал между движением
r_fig = 30  # Радиус фигуры

def create_circle(x, y, r, canvasName):
    x0, y0 = x-r, y-r
    x1, y1 = x+r, y+r
    return canvasName.create_oval(x0, y0, x1, y1, width=3, outline='red')


def create_figure(x, y, r, orbit, canvasName):
    x, y = x-orbit, y-orbit
    x0, y0 = x-r, y-r
    x1, y1 = x+r, y+r
    return canvasName.create_oval(x0, y0, x1, y1, fill='green', width=2, outline='black')

def move_circle(angle):
    if angle >= 360:
        angle = 0

    x = POINT_X + R * cos(radians(angle))
    y = POINT_Y + R * sin(radians(angle))
    
    canvas.coords(circle, x-r_fig, y-r_fig, x+r_fig, y+r_fig)
    
    angle += 1
    canvas.after(DELAY, move_circle, angle)

if __name__ == '__main__':
    window = tk.Tk()

    # Задание параметров экземпляра окна
    window.title('Движение фигуры')
    window.geometry(f'{X}x{Y}')
    window.resizable(width=False, height=False)
    
    # Задание окружности
    canvas = tk.Canvas(window, bg='white', height=X, width=Y)
    create_circle(POINT_X, POINT_Y, R, canvas)
    circle = create_figure(POINT_X, POINT_Y, r_fig, R, canvas)
    
    # Инициализация движения
    canvas.pack()    
    move_circle(0)
    
    # Показ экземпляра окна
    window.mainloop()
```