# Билет №22

## 1. Назначение и функции коммутаторов, типы коммутаторов и способы коммутации.

**Мост** – сетевое устройство для виртуального преобразования большой сети в сеть, формирующуюся из сегментов. Это как большой камень, разбитый на части и сцепленный наножвачкой.

Мосты делят большую сеть на сегменты, и составляют сеть из сегментов. Однако, в сетях часто нужен ещё один слой сегментации: когда разделяются не только сегменты сети, но и устройства (компудахтеры).

**Коммутатор** – сетевое устройство, конструктивно выполненное в виде сетевого концентратора, и действующее как высокоскоростной многопортовый мост. У него есть встроенный механизм коммутации, с помощью которого локальные сети имеют широковещательное сегментирование, а рабочие станции – выделенную полосу пропускания к себе.

> То есть, коммутатор – концентратор с прибамбассами, который работает как высокоскоростной мост с кучей портов.
>
> Коммутация у коммутаторов аппаратная, а у мостов – программная
> Маршрутизация у коммутаторов аппаратная, а у маршрутизаторов – программная 

Коммутатор способен «запоминать» адрес каждого компьютера, подключённого к его портам и передавать данные на компьютер адресата.

> Управляемый коммутатор – коммутатор с микропроцессором, который может кастовать лютую дичь (узкоспециализированный компьютер)
>
> Неуправляемый коммутатор – тупая штуковина без микропроцессора.

**Коммутатор также работает на канальном уровне и может вытворять следующие фокусы:**

- Создание и поддержка виртуальных сетей;
- Поддержка протоколов STP;
- Маршрутизация кадров;
- Фильтрация и контроль трафика;
- Передача данных с порта на порт.

**Коммутатор также имеет несколько режимов работы – о них слышал каждый школьник**:

- **Полудуплексный режим работы.**
  Одновременно лишь одно устройство может передавать данные.

  > Односторонняя одновременная передача.

- **Дуплексный режим работы.**
  Отправитель и получатель могут одновременно обмениваться данными.

  > Двусторонняя одновременная передача.

Одним из основных компонентов всего коммутационного оборудования является **коммутирующая матрица** – она представляет собой чипсет, соединяющий множество входов с множеством выходов на основе фундаментальных технологий и принципов коммутации.

**Коммутирующая матрица выполняет три функции:**

- Переключает трафик с одного порта матрицы на другой, обеспечивая их равнозначность;
- Предоставляет качество обслуживания (Quality of Service, QoS);
- Обеспечивает отказоустойчивость.

**Коммутатор может использовать одну из трёх схем взаимодействия своих блоков/модулей:**

1. **Коммутатор с ядром на основе коммутационной матрицы.**

   Порты связывают коммутационной матрицей. Это самый простой и быстрый способ организации взаимодействия процессоров портов – к  каждому из N входных портов подключается N выходных портов.
   Данный способ означает возрастание сложности схемы пропорционально квадрату количества портов коммутаторов.

   > **Плюсы:**
   >
   > 1. Высокая скорость коммутации;
   > 2. Структуру просто реализовать в микросхеме.
   >
   > **Минусы:**
   >
   > 1. Нет буферизации данных внутри коммутационной матрицы – они накапливаются во входных портах;
   > 2. Сложность наращивания числа коммутируемых портов.

   <p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1BRHVd1GQsfPbMIpGZREkP_vfyYF_sLco" style=" zoom: 50%;"><b><p style="text-align: center;">Коммутатор с коммутационной матрицей</p></b></p>

2. **Коммутатор с ядром на основе общей шины.**
   Порты связывают высокоскоростной шиной.
   Передача осуществляется в режиме разделения времени – каждому порту выделяется своё время передачи.
   Если скорость работы шины будет меньше чем суммарная скорость работы всех портов, то шина станет узким местом передачи данных – бутылочным горлышком фон Неймана

   > **Плюсы:**
   >
   > 1. Данные разбиваются на небольшие ячейки, что аннулирует задержку из-за начального ожидания доступности выходного порта.
   >
   > **Минусы:**
   >
   > 1. Промежуточной буферизации нет.

   <p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1Xc6Qo-ckKw8PG4Uw4kf_5xq1BsS0g5qX" style=" zoom: 50%;"><b><p style="text-align: center;">Коммутатор с общей шиной</p></b></p>

3. **Коммутатор с ядром на основе разделяемой памяти.**
   Порты связывают двухвходовой разделяемой памятью.
   Входные блоки процессоров портов соединяются с переключаемым входом разделяемой памяти, а выходные блоки этих же процессоров соединяются с переключаемым выходом этой памяти.
   Переключением памяти управляет менеджер очередей выходных портов.

   > **Плюсы:**
   >
   > 1. Требования к размеру буферной памяти процессора порта снижены.
   >
   > **Минусы:**
   >
   > 1. Память должна быть достаточно быстрой для поддержания скорости переписи данных между портами коммутатора.
   > 2. Масштабируемость архитектуры ограничена количеством портов – иначе операции записи/чтения будут слишком медленными.

   <p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1TJhPQN3ILn-AQfPxtkjN8jznxBvCf0jz" style=" zoom: 50%;"><b><p style="text-align: center;">Коммутатор с разделяемой памятью</p></b></p>

**Коммутаторы также классифицируются по связи с уровнями модели OSI, на которых они работают:**

- **Коммутатор L1.**
  Коммутатор уровня 1 (Layer 1) – просто концентратор. Работает на физическом уровне, когда информация передаётся сплошным потоком бит.

- **Коммутатор L2.**
  Коммутаторы L2 – почти все неуправляемые коммутаторы. Их задача – составление адресных таблиц в формате коммутационных таблиц. То есть, они банально обеспечивают коммутацию и передачу данных по MAC-адресу.

  Используются для сегментации сети и объединения рабочих групп.

  Плюсы:

  1. Прозрачность для протоколов верхнего уровня;
  2. Уровни доступа фактически работают как мост;
  3. Аппаратная поддержка коммутации второго уровня.

- **Коммутатор L2+ или L3 Lite.**
  Коммутаторы промежуточного уровня L2+ – коммутаторы L2 с расширенным функционалом, который зависит от производителя. В некоторых источниках называются коммутаторами L2 с функциями L3.

  Например, может быть добавлена поддержка статической маршрутизации, или дополнительные функции безопасности.

- **Коммутатор L3.**
  Коммутаторы L3 – устройства, работающие на 3-м уровне OSI (сетевом). Это управляемые коммутаторы, функционально идентичные (почти) маршрутизатору: главное отличие в маршрутизации, которая в коммутаторах выполняется аппаратно, а в маршрутизаторах – программно.

  Отличительная фишка – функция IP-маршрутизации.

  Основные функции:

  1. Определение оптимального пути при передаче данных через IP-маршрутизацию;
  2. Управление широковещательным и многоадресным трафиком с поддержкой протокола STP для устранения логических петель;
  3. Улучшенная фильтрация трафика с помощью сетевых протоколов;
  4. IP-фрагментация датаграммы.

- **Коммутатор L4.**
  Коммутаторы L4 – устройства, работающие на 4-м уровне OSI (транспортном).

  Отличительная фишка – виртуализация и возможность работы с приложениями вроде Telnet и FTP.

- **Многоуровневый коммутатор.**
  Коммутатор, сочетающий в себе уровни L2, L3 и L4 коммутаторов. То есть, передача данных осуществляется на основе информации о:

  - MAC-адресе назначения;
  - IP-адресе;
  - Типах протоколов в заголовке сетевого уровня;
  - Номере порта адресата/адресанта в заголовке транспортного уровня.

## 2. Модели распределенных приложений. Сетевые файловые системы.

**Распределённое приложение** – это программа, состоящая из нескольких взаимодействующих частей, каждая из которых, как правило, выполняется на отдельном компьютере (или другом устройстве) сети.

Распределённые приложения хранятся и выполняются в основном на платформах облачных вычислений и запускаются одновременно в нескольких системах. Они работают в одной сети и обмениваются данными друг с другом, чтобы выполнить определенную задачу или команду – в отличие от традиционного приложения, которое использует одну выделенную систему для выполнения поставленной задачи.

> Парадигма распределённых вычислений подразумевает наличие нескольких центров (серверов) хранения и обработки информации, реализующих различные функции и разнесённых в пространстве.

Основными преимуществами распределенных приложений являются:

- **Управляемость**, или способность системы эффективно контролировать свои составные части. Это достигается благодаря использованию управляющего ПО;
- **Производительность.** Обеспечивается за счёт возможности перераспределения нагрузки на серверы системы с помощью управляющего ПО;
- **Масштабируемость.** При необходимости физического повышения производительности, в распределённую систему легко интегрировать новые вычислительные ресурсы;
- **Расширяемость.** К распределённым приложениям можно добавлять новые составные части (серверное ПО) с новыми функциями.

Распределить части приложения между компьютерами сети можно несколькими способами:

- **Двухзвенные схемы распределения.** Функции серверного приложения распределены между двумя узлами (компьютерами) сети.

  > Например, распределённая база данных или удалённый доступ к данным.

  1. Один компьютер реализует *функцию управления данными* и называется **сервером**.
  2. Другой компьютер реализует *функцию представления данных* и называется **клиентом**.

- **Трёхзвенные схемы распределения.** Функции серверного приложения распределены между тремя узлами сети.

  > Например, клиент может содержать интерфейс, сервер приложений – логику приложения и обращения к базе данных, а сервер – базу данных.

  1. Один компьютер реализует *функцию управления данными* и называется **сервером**.
  2. Второй компьютер реализует *несколько прикладных функций* и называется **сервером приложений** – промежуточным уровнем, расширяющем функционал сервера и преобразовывающим взаимодействие сервера и клиента.
  3. Другой компьютер реализует *функцию представления данных* и называется **клиентом**.

Есть также ряд типовых архитектур распределённых приложений:

- **Клиент-сервер.**

  > Клиенты обращаются к серверам с запросами, которые те обрабатывают и возвращают результат.
  > Один клиент может обращаться с запросами к нескольким серверам.
  > Серверы также могут обращаться с запросами друг к другу.

- **Мобильные агенты.**

  >Когда клиент сам в состоянии выполнить ту задачу, решение которой он запросил у сервера, и данные также находятся у клиента – сервер отправляет на сторону клиента нужный модуль для решения задачи и тот его выполняет локально.

- **Тонкий клиент.**

  >Клиент выполняет очень ограниченную по функционалу задачу (приём с клавиатуры, мыши), а клиентская программа передаёт весь ввод пользователя (нажатия клавиш, движение мыши и т.д.) по сети серверу.
  >Сервер фактически берет на себя не только задачу управления данными, но и вообще все задачи по логике клиентского интерфейса.

- **Архитектура peer-to-peer (P2P).**

  >Приложение, выполненное в такой архитектуре, не имеет чёткого разделения на серверные и клиентские модули – все его части равноправны и могут выполняться на любых узлах.

**Сетевая файловая система** (NFS) – это распределённая файловая система. Она обеспечивает хранение файлов в сети и предоставляет пользователям доступ к файлам, расположенным на удалённых компьютерах.

> Например, с помощью команд операционной системы пользователи могут создавать, удалять, считывать, записывать и изменять атрибуты удаленных файлов и каталогов.

Во многих сетевых файловых системах клиентский компьютер может подсоединять и монтировать эти файловые системы к своим локальным файловым системам, обеспечивая удобный доступ к удаленным каталогам и файлам.

Службы NFS реализованы по принципу клиент-сервер. С программной точки зрения NFS – сетевая служба, включающая программы-серверы и программы-клиенты, взаимодействующие между собой по определенному протоколу.

- Компьютер, который позволяет пользователям сети получать доступ к своим файлам, обычно называют **файловым сервером**;
- Программу, которая работает на этом компьютере и обеспечивает совокупность услуг по доступу к файлам и каталогам на удаленном компьютере, также называют **файловым сервером**.

> Файловая система также является важнейшим компонентом любой распределённой системы, в которой она также является распределённой.

## 3. К каким конструкциям Java применим модификатор static?

**Объектно-ориентированное программирование** – концепция программирования, базирующаяся на использовании объектов.

> Если в структурной концепции главную роль играют **логика и понимание последовательности выполнения действия для достижения поставленной цели**, то в объектной концепции – **представление программы как системы взаимодействующих объектов**.

**Классом** в ООП понимается некая сущность, у которой можно смоделировать свойства и поведения. То есть, класс – некая идея сущности, своеобразный чертёж. Идею можно воплотить, и это воплощение будет называться **экземпляром** или **объектом**. У идеи есть некие характерные свойства – **атрибуты** или **поля**. Идее характерны некие способы взаимодействия – **методы**.

**Класс** – своеобразный чертёж объекта, позволяющий воплотить содержащуюся в нём идею в качестве экземпляра объекта.

**Класс** – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).

> `static` – своеобразный поводок к исходному классу, общий для всех его экземпляров.

Фича статического метода в том, что обычные методы у класса вызвать нельзя – только у его конкретного объекта. А вот статические методы позволяют для какого-нибудь класса `Треугольник` определить площадь по заданной формуле, например как `Треугольник.площадь(1, 2, 3)`.

Модификатор `static` обозначает некую реализацию поводка к классу, общую для всех экземпляров класса.

Может применяться к следующим конструкциям:

- **Поле**. Если к переменной, уровня класса, добавить модификатор `static`, то значение переменной будет привязываться к классу, а не к экземпляру (значение общее для класса);
- **Блок инициализации**. Это штука для инициализации внутренних переменных (аналог конструктора, но выполняется перед инициализацией класса или перед созданием экземпляра через конструктор). Если `static`, то относится ко всему классу, если нет – свой для каждого экземпляра;
- **Метод**. Если метод объявить статическим, то он может взаимодействовать только со статическими переменными или методами. Также привязан к классу, а не к объекту.
- **Внутренний класс**. Это класс, который находится внутри другого класса. Если объявлен статическим, то его экземпляр будет общим для всего класса.

## 4. Задача

Напишите программу тестирования. Тест состоит из 5 вопросов, на которые предполагаются ответы в виде чисел. Оценка выставляется автоматически в зависимости от числа правильных ответов (5 правильных ответов – 5; 4 правильных ответов – 4 и т.д.).

****

#### Пафосное решение:

```python
import numpy as np

N = 5
nums1 = np.random.randint(1, 10, size=N)
nums2 = np.random.randint(1, 10, size=N)
errors = 0

for num in range(N):
    res = int(input(f'{nums1[num]} + {nums2[num]} ='))
    if res != nums1[num] + nums2[num]:
        errors += 1

print(f'Ваша оценка: {N - errors} баллов')
```

#### Решение 71-х:

```
from random import *
ошибки = 0
for i in range(5):
    a = randint(2,10)
    b = randint(2,10)
    r = int(input(str(a)+' x '+str(b)+' = '))
    if r!=a*b:
          print('Неверно. Ответ = ',a*b)
          ошибки+=1
print('Число ошибок: ',ошибки)
if ошибки==0: print('Оценка: 5')
elif ошибки==1: print('Оценка: 4') 
elif ошибки==2: print('Оценка: 3') 
elif ошибки==3: print('Оценка: 2')
elif ошибки==4: print('Оценка: 1')
elif ошибки==5: print('Оценка: 0')
```