# Билет №26

## 1. Сообщения и сигналы. Кодирование. Аналого-цифровое преобразование. Дискретизация.

**Информация** – *сведения* о каких-либо процессах, событиях, фактах или предметах, *уменьшающие неопределённость события*. Её форма представления является сообщением, служащем для передачи информации от источника к получателю.

**Сообщение** – форма представления информации.

**Сигнал** – материальный источник сообщений. Представляет собой процесс изменения во времени физического состояния какого-либо объекта, служащего для отображения, регистрации и передачи сообщений.

> Источником информации является физический объект, который формирует конкретное сообщение. Получатель этого сообщения и является получателем информации.

**Процесс передачи информации** заключается в том, что сооб­щения преобразуются в сигналы и по системе связи передаются получателю. Получатель, зная закон соответствия между сообще­ниями и сигналами, может извлечь содержащуюся в сообщении информацию. Для верного декодирования каждому сигналу должно соответствовать одно определенное сообщение.

Сигналы, в сетях и телекоммуникациях, могут быть дискретными и аналоговыми.

**Аналоговые сигналы** – непрерывные во времени сигналы, они определены во все моменты времени.

> При **аналоговом** представлении физическая величина принимает бесконечное множество значений, причем ее значения изменяются непрерывно.

**Дискретные сигналы** – сигналы, представленные последовательностью отсчётов, т.е. значениями сигналов в дискретные моменты времени.

> При **дискретном** представлении физическая величина принимает конечное множество значений, причем ее величина изменяется скачкообразно.

<p style="text-align: center;"><img src="https://cf2.ppt-online.org/files2/slide/a/akPF1KYbvS2uiCrAIH9p5qlWxdNVeQ6EDGsJnM/slide-17.jpg" style=" zoom: 60%;"><b><p style="text-align: center;">Сигналы</p></b></p>

Чтобы передать сигнал по сети, его нужно преобразовать в цифровую форму. **Цифровые сигналы** – это сигналы дискретные во времени (или в пространстве) и квантованные по уровню. Вычислительные процедуры в компьютере выполняются именно в цифровых сигналах. Процесс преобразования аналогового сигнала в форму, совместимую с цифровой системой обработки и передачи информации, называется **кодированием**.

Кодирование сообщений производится специальным устройством, которое называется **кодером** (кодирующим устройством) источника сообщения (датчика информации). В кодере кодовые комбинации представляются в виде опредёленных состояний накопительных эле­ментов.

Кодирование сигнала происходит в два этапа:

1. **Дискретизация сигнала** (если аналоговый).
   Сигнал представляется в виде последовательности значений, взятых в дискретные моменты времени.

   > Разделение на временные промежутки.

2. **Квантование сигнала**.
   Вся область значений сигнала разбивается на уровни, каждому из которы присваивается некоторое число. Отсчёты сигнала сравниваются с уровнями квантования и в качестве сигнала выбирается это число.

   > Выборка примерного значения.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=14ZSAm5EUWAhxx31XS05rJUXB7rDmqiIT" style=" zoom: 50%;"><b><p style="text-align: center;">Дискретизация и квантование</p></b></p>

## 2. Многопоточная обработка данных в процессоре.

**Многопоточная обработка** – способность процессора обеспечивать одновременное выполнение нескольких потоков, поддерживаемых ОС. Потоки многопоточного приложения совместно используют ресурсы одного или нескольких ядре процессора, включая вычислительные блоки и кэш.

Многопоточная обработка работает на основе концепции конвейера. **Конвейеризация** (**конвейерная обработка**) – разделение подлежащей исполнению функции на более мелкие части (ступени), и выделении для каждой из них отдельного блока аппаратуры. Обработку любой машинной команды можно разделить на несколько этапов (несколько ступеней), организовав передачу данных от одного этапа к следующему.

Конвейерную обработку можно использовать для совмещения этапов выполнения разных команд. Производительность при этом возрастает благодаря тому, что одновременно на различных ступенях конвейера выполняются несколько команд.

> Многопроцессорная обработка дополняет концепт многопоточности – такая многопроцессорность направлена на увеличение использования одного ядра за счёт использования параллелизма на уровне потоков и на уровне команд.

Многопоточная обработка позволяет процессору одновременно выполнять больше инструкций, тем самым повышая общую производительность всей системы. Также, если один поток не может использовать все ресурсы процессора (из-за специфики решаемой задачи), то запуск других потоков позволяет предотворатить бездействие этих ресурсов.

Однако, потоки могут мешать друг другу, разделяя аппаратные ресурсы вроде кэша или буферов. Тогда, время однопоточного выполнения может не только не улучшиться, но и даже ухудшиться. Аналогично, может упасть производительность однопоточного выполнения, если аппаратная реализация оптимизирована под многопоточность.

## 3. Примеры применения функций в языках программирования. Рекурсия.

**Функция** – способ группирования набора операторов, позволяющий выполнять их более одного раза, группированный в процедуру, вызываемую по имени.

Функции повышают уровень модульности программы и облегчают ее проектирование.

> Функция – некий участок кода, который "сохраняется" с возможностью дальнейшего применения по её имени.
>
> Функции позволяют упрощать и сокращать код, делать его более отказоустойчивым и модифицируемым.

**Я ХЗ ЧТО СЮДА ПИСАТЬ, НУ ЭТО ЖЕ ОЧЕВИДНО**

У функции могут быть аргументы – параметры, которые в неё передаются. Они могут быть обязательными или необязательными (если есть значение по умолчанию).

```python
# Функция на Python
def rock_and_stone(a):
    print('Rock and Stone for', a)
```

```java
// Java Hutt
public static int func(){
    int n = 10;
    return n;
}
```

```c#
// C#
public Boolean StartService(int a)
{
    Console.WriteLine(a);
    return a + 2;
}
```

Существуют также **рекурсивные функции** – функции, которые вызывают сами себя либо прямо, либо косвенно. Рекурсия позволяет программно обходить структуры данных произвольной и непредсказуемой формы и глубины (маршруты путешествия, кроличья нора, туннели Оргриммара).

**Плюсы рекурсии:**

1. Смотри **плюсы рекурсии**;
2. Компактная запись;
3. Легче в отладке, так как требует меньше строк кода;
4. В ряде задач, вроде вычисления факториала или ряда Фиббоначчи, функция быстрее выполняется (относительно циклов), за счёт кэширования результатов.

**Минусы рекурсии:**

1. Смотри **минусы рекурсии**;
2. Может привести к бесконечному циклу, если разраб – долбоёб;
3. Во время выполнения, требует много места на поддержание стека вызовов;
4. Может привести к переполнению стека.

Например, рекурсивная функция вычисления факториала:

```python
def factorial_recursive(n):
    if n == 1:
        return n
    else:
        return n*factorial_recursive(n-1)
```

## 4. Задача

Разработайте программу «Оплата ЖКХ», позволяющую отображать записи о владельцах квартир, выполнять их редактирование (изменение выбранной записи), добавление новой записи, удаление выбранной записи, осуществлять поиск по критериям, сохранять содержимое в текстовом файле с заданным именем и загружать данные из этого текстового файла.

****

```python
#Функция для считывания файла в словарь, r- режим чтения
def file_to_dict(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        data = f.readlines()
        owners = {}
        for record in data:
            info = record.strip().split(': ')
            owner, name = info[0], info[1]
            if not owner in owners:
                owners[owner] = name
        return owners


# Функция для записи словаря в файл, w- режим записи
def dict_to_file(owners, filename):
    #открываем файл 
    with open(filename, 'w', encoding='utf-8') as f:
        for owner, name in owners.items():
            f.write(f'{owner}: {name}\n')

owners_file = 'ЖКХ.txt'
OwnersBook = file_to_dict(owners_file)
# команды
while True:
    command = int(input("""\nМеню:
1. Вывод владельцев
2. Поиск владельца
3. Добавление владельца
4. Переименование владельца
5. Удаление владельца
0. Выход из программы
Введите действие:"""))
    print()
    # проверка какая команда выбрана
    if command == 1:
        print('Вывод владельцев:')
        for number, name in OwnersBook.items():
            #вывод результата
            print(f'Номер квартиры: {number}, Владелец: {name}')
    elif command == 2:
        #поиск, уточнение 
        take = int(input("""Поиск контакта.
Контакт нужно найти по номеру квартиры (1) или по Владельцу (2)?"""))
        if take == 1:
            number = input('Номер квартиры:')
            #проверка есть ли такая квартира в базе
            if number in OwnersBook:
                name = OwnersBook[number]
            #если есть
                print(f'Номер квартиры: {number}, Владелец: {name}')
            else:
                print(f'Квартира не найдена!')
            #поиск по фамилии владельца
        elif take == 2:
            name = input('Владелец:')
            if name in OwnersBook.values():
                number = list(OwnersBook.keys())[list(OwnersBook.values()).index(name)]
                #если есть выводим результат
                print(f'Номер квартиры: {number}, Владелец: {name}')
            else:
                print(f'Владелец не найден!')
        else:
            break
            #Добавление владельца
    elif command == 3:
        print('Добавление владельца:')
        #вод данных
        number = input('Номер квартиры:')
        name = input('Владелец:')
        #запись
        OwnersBook[number] = name
        print(f'Владелец добавлен!')
    elif command == 4:
        print('Переименование владельца:')
        number = input('Номер квартиры:')
        #проверяем, есть ли такая квартира в базе
        if number in OwnersBook:
            name = OwnersBook[number]
            print(f'Номер квартиры: {number}, Владелец: {name}')
            #меняем владельца
            name = input('Введите нового Владельца')
            OwnersBook[number] = name
            print(f'Данные изменены!')
        else:
            print(f'Данные не найдены!')
    elif command == 5:
        print('Удаление владельца:')
        number = input('Номер квартиры:')
        #аналогичная проверка
        if number in OwnersBook:
            print(f'Номер квартиры: {number}, Владелец: {name}')
            #функция удаления
            del (OwnersBook[number])
            print(f'Владелец удалён!')
        else:
            print(f'Данные не найден!')
    else:
        break

    dict_to_file(OwnersBook, owners_file)
```
