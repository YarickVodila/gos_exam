# Билет №7

## 1. Графы. Обходы графов.

**Граф** – математическая модель набора связей (отношений). То есть, это наглядное представление отношений между какими-либо объектами.

> В математическом виде, граф: (V, E, $\phi$). V – множество вершин, E – множество рёбер, $\phi$ – отношения между ними.

**Обход графа** – это переход от одной его вершины к другой в поисках свойств связей этих вершин. Связи (линии, соединяющие вершины) называются **рёбрами** графа, а вершины  – **узлами**. Если у узла нет потомков, он называется **листом**.

**Путь в графе** – некая последовательность вершин, каждая из которых соединена со следующей ребром. Численно путь характеризуется суммой весов этих рёбер.

**Ориентированный граф** – граф, рёбра которого имеют направление. То есть, из вершины 1 может быть дуга в вершину 2, но не всегда будет дуга из вершины 2 в вершину 1. В орграфе у ребра всегда есть начало и конец.

**Неориентированный граф** – граф, рёбра которого не имеют направления. То есть, если есть ребро между вершинами – из первой вершины всегда можно попасть во вторую, а из второй вершины – в первую.

Существует два основных метода обхода графа: DFS и BFS.

### Обход графа в глубину (DFS)

**Метод обхода графа в глубину** или `DFS` – обход графа "как можно глубже". Этот метод идёт по такому условию: если у элемента остались непросмотренные соседи, обход переходит на неё. Обход ведётся для каждой вершины, то есть можно помечать пройденность вершин (к примеру, как дополнительный массив пройденных вершин).

> Мыш кродётся по лабиринту и ищет еду.

**DFS двигается по граням туда и обратно, реализуется стеком.**

Как правило, это рекурсивная процедура: рекурсивно перебираются все исходящие из рассматриваемой вершины рёбра. Если ребро ведёт в вершину, которая не была рассмотрена ранее, то рекурсивный алгоритм обхода запускается для этой вершины, а после его работы – аналогично ко всем другим рёбрам.

В данной реализации предполагается, что до обработки графа, все его вершины являются непросмотренными, то есть окрашенными в белый цвет. Тогда, нужно пройти по всем вершинам графа, и если вершина белая – выполнить для неё алгоритм:

1) Перекрасить вершину в чёрный цвет, то есть пометить просмотренной.
2) Для всех смежных вершин, для актуальной, окрашенных в белый цвет, рекурсивно выполнить алгоритм, начиная с шага 1.

Такой проход позволяет выявлять циклы: если на шаге 2 будет вершина, окрашенная в чёрный цвет, то это означает нахождение цикла.

> Применяется в головоломках с единственным решением, для обнаружения циклов на графе, для нахождения пути между вершинами.

### Обход графа в ширину (BFS)

**Метод обхода графа в ширину** или `BFS` – обход графа "как можно шире".

> Круги, от упавшего в воду камня, огибают препятствия при распространении.

**BFS распространяется по соседям в поисках цели, реализуется очередью.**

Этот метод идёт по такому условию: берётся некая вершина, а затем посещаются все вершины на расстоянии $k$ от неё, после чего $k+1$ и аналогично до достижения просмотренных вершин или конца графа.

Когда для вершины просматриваются все прямые соседи, она помечается как просмотренная. Тогда, можно разбить по цветам: белый – вершины, которая ещё не достигнута; серый – уже добавленная в очередь вершина; чёрный – извлечённая из очереди вершина.

Используется очередь вместо стека, так как проход идёт равномерно во все стороны.

> Применяется для определения кратчайших путей, индексации веб-страниц ботами, поиска в соцсетях и нахождения доступных соседних узлов в P2P сетях типа BitTorrent.

## 2. Криптографические механизмы конфиденциальности, целостности и аутентичности информации. Электронная цифровая подпись.

**Криптография** – наука о методах преобразования (шифрования) информации с целью сокрытия и защиты её от несанкционированных пользователей.

**Ключ** – сменный элемент шифра, который применён для шифрования конкретного сообщения.

> Криптография представляет собой совокупность методов преобразования данных, направленных на то, чтобы сделать эти данные бесполезными для злоумышленника.

Такие преобразования позволяют решить главные вопросы, касающихся безопасности информации: защиту её конфиденциальности, целостности и аутентичности.

В основные криптографические механизмы входят:

- **Механизм организации конфиденциальности информации**.
  В системе должно осуществляться шифрование всей конфиденциальной информации, записываемой на съёмные устройства (флешки, диски)  или передаваемой по сети. Должны автоматически очищаться области внешней памяти, содержащие ранее незашифрованную информацию.
- **Механизм обеспечения целостности информации**.
  В системе должна обеспечиваться целостность программных средств, неизменность программной среды. Целостность и неизменность должны проверяться по аттестованным алгоритмам, в соответствии с актуальными ГОСТ.
- **Механизм организации аутентичности информации**.
  В системе должны использоваться разные криптографические ключи для шифрования информации, относящейся к разным группам доступа. Доступ к информации и ключам должен дополнительно контролироваться специальными алгоритмами. Сертификация средств криптографической защиты должна проводиться специальными и лицензированными центрами.

**Электронная цифровая подпись** (ЭЦП) – уникальная цифровая информация в виде комбинации символов. Из этой информации можно узнать, кто именно и когда подписал документ. Формируется для **исходного** состояния документа. Любое изменение документа = новая подпись.

> Цифровой и официально утверждённый законом аналог личной подписи от руки. Применяется для подписания и заверения электронных документов.

Механизм ЭЦП, обычно, используется на алгоритмах асимметричного шифрования и включает две процедуры: формирование подписи отправителем (использует ключ отправителя) и верификация получателя (использует общедоступный ключ)

Использование ЭЦП позволяет осуществить:

- **Контроль целостности** и защита от подделки документа.
  ЭЦП вычисляется для исходного состояния документа и соответствует лишь ему. Изменение документа (нарушение целостности) делает подпись недействительной.
- **Подтверждение авторства** и **невозможность отказа** от него.
  Создать ЭЦП можно лишь зная определённый ключ, который должен быть известен только владельцу. Зная ключ, можно подтвердить авторство. При этом, отказаться от ЭЦП нельзя.

ЭЦП может формироваться на основе алгоритмов шифрования:

- **Алгоритмы симметричного шифрования**.
  Основаны на использовании одного и того же секретного ключа для шифрования и дешифрования информации.

  > Одноключевые, с секретным ключом.

- **Алгоритмы асимметричного шифрования**.
  Основаны на использовании общедоступного ключа для шифрования, а для дешифрования – другой, являющийся секретным. Знание общедоступного ключа не позволяет определить секретный ключ.

  > С открытым ключом.

## 3. Назовите принципы ООП и расскажите о каждом.

**Объектно-ориентированное программирование** – концепция программирования, базирующаяся на использовании объектов.

> Если в структурной концепции главную роль играют **логика и понимание последовательности выполнения действия для достижения поставленной цели**, то в объектной концепции – **представление программы как системы взаимодействующих объектов**.

**Классом** в ООП понимается некая сущность, у которой можно смоделировать свойства и поведения. То есть, класс – некая идея сущности, своеобразный чертёж. Идею можно воплотить, и это воплощение будет называться **экземпляром** или **объектом**. У идеи есть некие характерные свойства – **атрибуты** или **поля**. Идее характерны некие способы взаимодействия – **методы**.

В современном ООП принято выделять пять основных принципов (механизмов):

- **Абстракция**. Сущности и взаимодействия можно смоделировать (представить в качестве некой концепции) как классы и методы.

  > Яблок много разных бывает – красные, зелёные, вкусные и червистые. Но городские жители при слове "яблоко" знают о каком объекте речь – они знают идею "яблочности". Вот эта идея "яблочности" и есть абстракция, то есть набор всех таких характеристик объекта.

- **Инкапсуляция**. Свойство системы, позволяющее объединять данные и методы, работающие с ними, в классе, попутно скрыв детали реализации от пользователя.

  > Наполнить желудок едой можно напрямую, положив еду в желудок. Это опасно, поэтому прямой доступ к желудку закрыт. Наполнение желудка происходит через элемент интерфейса "рот", а обычному пользователю не обязательно знать, что между ртом и желудком есть другие элементы говнокода.

- **Наследование**. Свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

  > На заводе есть общая идея стола, прямо таки столистый стол (**родительский класс**). Но людям нужны разные столы, и поэтому на заводе есть другие коробки с идеями письменного, обеденного или журнального столика – все они являются наследником (**дочерним классом**) идеи столистого стола, но по своему изменяют её.
  >
  > Я получил власть, которая и не снилась моему отцу!

- **Полиморфизм**. Свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

  > Человек может /есть. Кошка может /есть. Но эти действия проходят по разному, и в обычном диалоге нам не нужно уточнять "а вот кошка есть с помощью такого комплекта зубов, языка интегральной формы X и атомного излучателя", мы просто понимаем "кошка ест, чо те непонятно".
  >
  > Аналогично с вождением велосипеда – умеешь ездить на одном, сможешь поехать и на другом.

- **Композиция**. Объекты зачастую формируются или состоят из других объектов.

  > Компьютер можно считать объектом. Компьютер содержит разные устройства – видеокарту, процессор, материнскую плату и так далее. Эти устройства тоже можно считать объектами.
  > Компьютер – объект, содержащий другие объекты.

## 4. Задача

Составьте блок-схему и напишите тестовую программу для проверки умения умножать числа от 2 до 9 на числа в пределах от 1 до 100. Программа должна вывести 10 примеров. Оценка выставляется по следующему правилу: за 10 правильных ответов – «отлично», за 9 и 8 – «хорошо», за 7 и 6 «удовлетворительно», за 6 и менее – «плохо».

****

#### Пафосное решение:

```python
import numpy as np

def generate_numbers(count, diap1, diap2):
    mul1 = np.random.randint(*diap1, size=count)
    mul2 = np.random.randint(*diap2, size=count)
    for i in range(count):
        yield mul1[i], mul2[i]

def quiz(count, diap1, diap2):
    correct_answers = 0
    for num1, num2 in generate_numbers(count, diap1, diap2):
        res = input(f'{num1} * {num2} =')
        if res.isdigit() and num1*num2 == int(res):
            print('Правильно!')
            correct_answers += 1
        else:
            print('Неверно!')
    
    if correct_answers == 10:
        return 'Отлично'
    elif correct_answers in [9, 8]:
        return 'Хорошо'
    elif correct_answers in [7, 6]:
        return 'Удовлетворительно'
    else:
        return 'Плохо'

TOTAL = 10
diap1, diap2 = (2, 9), (1, 100)
result = quiz(TOTAL, diap1, diap2)
print(result)
```

#### Решение 71-х:

```python
import random

i=0
k=0
for i in range(10):
    a = random.randint(1, 9)
    b = random.randint(1, 9)
    print(a," x ",b )
    result = int(input())
    if ((a*b) == result):
        k = k+1;
if (k == 10):
    print("Отлично")
elif (8 <= k <= 9):
    print ("Хорошо")
elif (6 <= k <= 7):
    print("Удовлетворительно")
else:
    print("Плохо")
```