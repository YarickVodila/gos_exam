# Билет №19

## 1. Конвейерные вычислительные системы.

**SIMD** или **single instruction stream / multiple data stream** – одиночный поток команд и множественный поток данных.
Комповые прототипы вроде illiac, суперкомпьютеры 70-х, вроде CRAY-1.

>В таких компах есть только один поток команд, но он поддерживает векторные команды – одну арифметическую операцию можно выполнять сразу над многими данными.

Архитектура **вычислительных систем с конвейерной обработкой информации** базируется на двух принципах: конвейеризации и векторизации.

**Конвейеризация** (**конвейерная обработка**) – разделение подлежащей исполнению функции на более мелкие части (ступени), и выделении для каждой из них отдельного блока аппаратуры. Обработку любой машинной команды можно разделить на несколько этапов (несколько ступеней), организовав передачу данных от одного этапа к следующему.

Конвейерную обработку можно использовать для совмещения этапов выполнения разных команд. Производительность при этом возрастает благодаря тому, что одновременно на различных ступенях конвейера выполняются несколько команд.

> Конвейеризация широко применяется во всех современных быстродействующих процессорах.

**Векторизация** – введение в систему команд набора векторных операций, которые позволяют оперировать с целыми массивами данных.

Основное назначение векторных операций состоит в распараллеливании выполнения операторов цикла, в которых обычно сосредоточена большая часть вычислительной работы.

> В векторно-конвейерной системе имеется один (или небольшое число) конвейерный процессор, выполняющий векторные команды путём засылки элементов векторов в конвейер с интервалом, равным длительности прохождения одной, стадии обработки.
>
> Скорость вычислений зависит только от длительности стадии и не зависит от задержек в процессоре в целом.

## 2. АТД - очередь. Реализация с помощью указателей.

Нотация **О-большое** описывает скорость работы алгоритма. Оно не сообщает скорость алгоритмов в секундах, а *позволяет сравнить количество операций*.

> Например, для списка размером **N** поиск должен выполнить **N** операций для нахождения последнего элемента, поэтому поиск имеет вид O(n).

**Указатель** – ячейка памяти, чьё значение указывает на другую ячейку.

> Указатель – своеобразный ярлык, который можно использовать для указания на какой-либо объект или другой ярлык.

**Абстрактные типы данных** являются некой математической моделью того, по какому макету должны храниться данные в структуре, и как должен обеспечиваться доступ ко всему объёму данных.

Один из основных представителей АТД – **связный список**. Это линейная структура, данные в которой хранятся последовательно (один элемент за другим, без разветвлений).

**АТД очередь** – тот же связный список, но с ограничениями: вставлять элементы можно лишь с одного конца, а удалять и обрабатывать – с другого.

> АТД очередь – типичная очередь на кассе, где первый вошедший выходит первым, а остальные – в порядке своего поступления ~~в УрТИСИ~~.

Очереди часто используются в программах для реализации буфера, в который можно положить элемент для последующей обработки, сохраняя порядок поступления.

> Например, если БД поддерживает только одно соединение, можно использовать очередь потоков, которые будут ждать своей очереди на доступ к БД.
>
> Ещё один пример – считывание ввода с клавиатуры.

Базовые операции очереди:

- Вставка элемента в конец очереди (`Enqueue`);
- Удаление элемента из начала очереди (`Pop`);
- Обработка элемента из начала очереди (`Peek`).

Временная сложность базовых операций равна O(1): так как работа идёт лишь с одним (верхним или нижним) элементом, то нужен всего один шаг чтобы вставить или удалить новый элемент.

В случае поиска или изменения элемента, нужно буквально разбирать очередь, то есть их временная сложность равна O(n).

Очереди можно **реализовать через зацикленные массивы**, которые представлены в виде круговой и непрерывной последовательности ячеек. Такая реализация более оптимальна в плане памяти, однако затруднительна в реализации и предполагает использование некоего статического массива, так как динамический массив убивает всю экономию памяти.

Очереди можно **реализовать через указатели**. Такая реализация оптимальнее массивов – вместо перемещения (при вставке или удалении) по списку, можно просто сохранять указатели на "голову" и "хвост". Это существенно упрощает навигацию по структуре.

Реализация через указатели представляет собой тот же связный список на указателях, однако с прямым доступом лишь к "голове" и "хвосту". Это уменьшает потребление памяти, но ухудшает навигацию и повышает разброс элементов структуры внутри памяти.

Базовую концепцию очереди можно доработать в **АТД дек** – очередь, у которой базовые операции могут быть применимы как к первому так и к последнему элементу списка.

> Голова может выполнять функции хвоста и наоборот.

## 3. Имеет ли смысл объявлять метод private final в ООП? Какие особенности инициализации final переменных?

**Объектно-ориентированное программирование** – концепция программирования, базирующаяся на использовании объектов.

> Если в структурной концепции главную роль играют **логика и понимание последовательности выполнения действия для достижения поставленной цели**, то в объектной концепции – **представление программы как системы взаимодействующих объектов**.

**Классом** в ООП понимается некая сущность, у которой можно смоделировать свойства и поведения. То есть, класс – некая идея сущности, своеобразный чертёж. Идею можно воплотить, и это воплощение будет называться **экземпляром** или **объектом**. У идеи есть некие характерные свойства – **атрибуты** или **поля**. Идее характерны некие способы взаимодействия – **методы**.

Модификатор `final` – специальное ключевое слово, указывающее на невозможность дальнейшего изменения объекта.

> Если объект является ссылкой на другой объект, то `final` просто запретит изменение ссылки, но у того другого объекта можно будет поменять значение.

Однако, эта невозможность варьируется от объекта:

- Если **конструктор** объявить как `final`, программа не запустится – это тупо, блять (с). `final` используется для остановки ПЕРЕОПРЕДЕЛЕНИЯ, а у конструктора итак нет этой возможности.

> Легко сломать человека, не представляющего свою жизнь без указаний.
> Для этого, нужно просто запретить ему кормить слонов… там где их нет, не было и не будет.

- Если **переменную** объявить как `final` , то после присвоения её не изменить. В той же Java нет отдельного ключевого слова для констант, обычно их объявляют как `static final`.
- Если **поле** объявить как `final`, то после инициализации его не изменить.
- Если **метод** переопределить как `final`, то его нельзя изменить в дочерних классах.
- Если **класс** переопределить как `final`, то ему нельзя иметь наследников (~~Китай~~).

Если переменную инициализировать через `final`, то её значение не может быть изменено после присвоения.

Главная особенность инициализации `final` переменных заключается в их взаимодействии с объектами ссылочного типа, вроде массивов.

Так, если присвоить подобной переменной массив, то по факту она будет хранить ссылку на объект массива в памяти. Присвоить переменной другой массив будет нельзя, но в самом массиве вполне спокойно можно поменять элементы даже по прямому обращению через `final` переменную.

Как объяснено в предыдущем вопросе, если объявить метод с ключевым словом `final`, то в дочерних классах его нельзя изменить.

> Согласно ответам с ресурса, откуда Панов ~~спёр~~ взял эти вопросы, такой метод не виден для наследников и по умолчанию не может быть ими переопределён.
>
> Однако, согласно логике и поисковику, `final` относится только к ПЕРЕОПРЕДЕЛЕНИЮ, но не к зоне видимости. Вопрос спорный.

## 4. Задача

Переведите каждое из исходных чисел в двоичную систему счисления. Выполните действия в двоичной системе счисления: (29*7+44/11)-171. Результат перевести в десятичную систему счисления. Проверить правильность решения.

****

**Для перевода числа в двоичную систему, быстрее всего представить его как сумму степеней двойки:**

- $29_{10}=16+8+4+1=2^4+2^3+2^2+2^0=11101_{2}$

- $7_{10}=2^2+2^1+2^0=111_{2}$

- $44_{10}=32+8+4=2^5+2^3+2^2=101100_{2}$

- $11_{10}=2^3+2^1+2^0=1011_{2}$

- $171_{10}=128+32+8+2+1=2^7+2^5+2^3+2^1+2^0=10101011_{2}$

**Сложение 2-чных чисел:** поразрядно складываем цифры в столбиках. Если в разряде в сумме получается 2, единица переносится в соседний слева разряд. (Всё как в обычной арифметике, просто в обычке перенос при 10).

**Вычитание 2-чных чисел:** как обычно.

**Умножение и деление 2-чных чисел:** один в один как для обычных чисел.



<p style="text-align: center;"><img src="https://prog-cpp.ru/wp-content/uploads/2014/03/13div5.png" style=" zoom: 100%;"><b><p style="text-align: center;">Умножение и деление двоичных чисел</p></b></p>

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1GbBdmNS3ExBTkHlvymENb4Epnnd_yAwS" style=" zoom: 25%;"><b><p style="text-align: center;">Выполнение двоичных действий</p></b></p>

**Проверка:**

$(29*7+44/11)-171=203+4-171=36$