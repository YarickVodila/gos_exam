# Билет №5

## 1. Представление чисел в памяти компьютера.

Числовые данные обрабатываются в компьютере в двоичной системе счисления. Числа хранятся в памяти компьютера в двоичном коде (в виде последовательности нулей и единиц) в одной из двух форм: в форме с фиксированной точкой и в форме с плавающей точкой.

**Форма с фиксированной точкой** применяется к целым числам.
Часть памяти компьютера, в которой хранится одно число – **ячейка**. Минимальный размер ячейки, где может храниться целое число – 8 бит или 1 байт. Ячейки могут использовать 8, 16, 24 или 32 разряда памяти (1, 2, 3 и 4 байта).

Целые положительные числа можно записать в **беззнаковом представлении**. Его двоичная форма записывается в ячейку с конца: последней цифре числа соответствует последний разряд ячейки. Свободные разряды слева заполняются нулями.

> В ячейку можно поместить $2^n-1$ беззнаковых чисел, где $n$ – количество битов в ячейке.

Для представления чисел, которые участвуют в вычислительных операциях, используется **представление со знаком**. В такой форме записи старший разряд всегда отводится под знак (0 для положительных чисел и 1 для отрицательных).

Все отрицательные значения в компьютере хранятся в **обратном** (дополнительном) коде, а положительные – в **прямом**. Для получения обратного кода, нужно:

1. Взять модуль числа и перевести его в двоичную систему (получим прямой код);

   > $-42_{10}\rightarrow 42=101010_2$

2. Инвертировать сигналы: нули заменяются на единицы, а единицы – на нули;

   > $101010_2=00101010_2 \rightarrow 11010101_2$

3. К полученному числу добавляется единица.

   > $11010101_2+1=11010110_2=-42_{10}$

> Максимальное знаковое число для ячейки равно $2^{n-1}-1$ положительных и $2^{n-1}$ отрицательных.
>
> Хранение отрицательных чисел в обратном коде позволяет процессору заменить операцию вычитания на операцию сложения: не нужно определять положительность или отрицательность величины, а затем сравнивать модули для определения знака результата – достаточно просто сложить числа.

**Форма с плавающей точкой** применяется к вещественным числам. Люди используют естественную форму записи вещественных чисел ($42 \cdot 10^5$), но в компьютерах применяется экспоненциальная форма записи ($a = \pm m \cdot q^p$):

- $m$ – мантисса, представляющая собой правильную дробь (числитель меньше знаменателя, т.е верх меньше низа);
- $q$ – система счисления, в которой представлено число;
- $p$ – порядок числа (количество цифр перед запятой).

В памяти компьютера, один разряд отводится под знак мантиссы, один – под знак порядка, а остальное – под саму мантиссу и порядок числа.

> Чем больше **бит** отводится под мантиссу – тем точнее представляемая величина.
> Чем больше **ячеек** отводится под порядок – тем шире диапазон от наименьшего до наибольшего числа.

<p style="text-align: center;"><img src="https://tvoyapecarnya.ru/wp-content/webp-express/webp-images/doc-root/wp-content/uploads/2021/09/image-23.png.webp" style=" zoom: 100%;"><b><p style="text-align: center;">Формат записи "с плавающей запятой"</p></b></p>

## 2. Назначение ЭМ ВОС и всех уровней протокольного стека.

### 2.0 Об эталонной модели OSI

Многоуровневая модель для описания сетевых протоколов и операций (OSI) обеспечивает следующие преимущества.

- **Упрощение разработки протоколов.**
  Протоколы, работающие на определенном уровне, определяют формат обрабатываемых данных и интерфейс верхних и нижних уровней;
- **Стимулирование конкуренции.**
  Продукты разных поставщиков могут взаимодействовать друг с другом;
- **Предотвращение влияния изменений технологий или функций одного уровня на другие уровни** (верхние и нижние);
- **Общий язык для описания функций сетевого взаимодействия.**

Эталонная модель OSI определяет широкий список функций и сервисов, реализуемых на каждом уровне. Она обеспечивает единообразное применение всех сетевых протоколов и сервисов, описывая то, что необходимо сделать на определённом уровне, но не предписывая конкретные способы выполнения.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1tRfDm3KoUvZylfxGGMbLSadxGNxtut-r" style=" zoom: 50%;"><b><p style="text-align: center;">Уровни модели OSI</p></b></p>

Уровни модели OSI принято называть по номеру, но их можно упоминать и по названию:

| Уровень                      | Описание                                                     |
| :--------------------------- | :----------------------------------------------------------- |
| **7. Прикладной**            | Содержит протоколы для обмена данными между процессами.      |
| **6. Уровень представления** | Обеспечивает общее представление данных, передаваемых между службами уровня приложений. |
| **5. Сеансовый**             | Предоставляет услуги уровню представления для организации его диалога и управления обменом данными. |
| **4. Транспортный**          | Определяет службы для сегментирования, передачи и повторной сборки данных для индивидуальной связи между конечными устройствами. |
| **3. Сетевой**               | Предоставляет функции для обмена отдельными частями данных по сети между указанными оконечными устройствами. |
| **2. Канальный**             | Описывает способы обмена кадрами данных при обмене данными между устройствами по общей среде передачи данных. |
| **1. Физический**            | Представляет данные в понятном для устройств формате. Обеспечивает непосредственную взаимосвязь со средой передачи данных. |

### 2.1 Физический уровень

> Отвечает за обмен физическими сигналами между физическими устройствами.

Для передачи данных по сети необходимо сначала установить физическое подключение к ней. В качестве такого подключения может использоваться проводная или беспроводная связь по некой среде передачи данных – это зависит от сети.

Физический уровень OSI (уровень 1) обеспечивает перемещение битов, формирующих кадр канального уровня, по физической среде. Он кодирует такой кадр в виде последовательности сигналов, которые принимаются устройствами и на них восстанавливаются (тоже средствами физического уровня) в кадр.

Основные элементы уровня: физические компоненты (устройства, среды передачи и т.п), способы кодирования данных, способы передачи сигналов.

> Протоколов на этом уровне нет – работает спецназ: радиосвязь, электрические провода, волоконно-оптические провода…

### 2.2 Канальный уровень

> Обеспечивает установление, поддержание и разъединение соединений каналов связи.
>
> Задача: сформировать кадры с адресом отправителя и получателя, после чего отправить их по сети.

Канальный уровень OSI (уровень 2) подготавливает сетевые данные для физической сети. Он отвечает за связь между сетевыми интерфейсными картами, то есть его задача – работа с соединениями информационных каналов: их нужно устанавливать, поддерживать и разъединять.

> Если бы канального уровня не существовало, протоколы сетевого уровня (т.к он стоит выше), например IP, должны были бы обеспечивать соединение для всех типов средств подключения, которые могли встретиться на пути следования пакета. Более того, им пришлось бы каждый раз адаптироваться к новой сетевой технологии или среде.

На канальном уровне, устройство имеет физический адрес – это MAC-адрес, задаваемый физическим оборудованием (сетевой платой).

По стандарту IEEE, канальный уровень делится на два отдельных подуровня:

- **Подуровень LLC (Logical Link Control)**, управляющий логическими связями. Отвечает за связь с сетевым уровнем.
- **Подуровень MAC (Media Access Control)**, управляющий доступом к среде. Отвечает за инкапсуляцию данных и доступ к среде передачи данных (связь с физическим уровнем).

Работа канального уровня начинается с синхронизации двух удалённых устройств.

> **Синхронизация** – процесс установления и поддержания временных соотношений между двумя и более процессами.

Синхронизация, в свою очередь, начинается с запуска драйвера соответствующего протокола. На компах, обычно, используется Ethernet.

> Примеры протоколов: 802.11 (беспроводная связь), Ethernet (сетевой порт компуктера), Frame Relay (как Ethernet, но специализирован на подключениях), HDLC (блть), Token Ring (блть), FDDI (блть), MPLS (блть).

### 2.3 Сетевой уровень

>Выполняет маршрутизацию блоков данных через сеть.
>
>Протоколы этого уровня занимаются построением маршрута от одного сетевого устройства к другому, с учётом всех потенциальных неполадок внутри сети.

Сетевой уровень OSI (уровень 3) предоставляет сервисы, позволяющие хостам обмениваться данными по сети. Для этого, протоколы данного уровня выполняют четыре основных операции:

- **Адресация оконечных устройств**. Хостам необходимо назначить уникальный IP-адрес для возможности их идентификации в сети;
- **Инкапсуляция**, во время которой источник IP-пакета добавляет информацию заголовка IP, например IP-адрес узла источника (отправляющего) и узла назначения (получающего).
- **Маршрутизация**. Сетевой уровень предоставляет сервисы, с помощью которых пакеты направляются к узлу назначения в другой сети. Для этого, пакет должен быть обработан маршрутизатором – он выбирает пути для пакетов и направляет их к узлу назначения (это и есть маршрутизация).
- **Деинкапсуляция**, во время которой получатель IP-пакета проверяет IP-заголовок пакета: IP-адрес назначения в нём должен совпадать с собственным IP-адресом устройства – тогда пакет, уже без заголовка IP, передаётся на транспортный уровень.

> Примеры протоколов: IPv4, IPv6, ICMP (для диагностики), RIP (древняя маршрутизация по локальным сетям), BGP (маршрутизация локальных сетей в сети интернет), OSPF (маршрутизация по локальным сетям), ARP (найти MAC-адрес по IP), RARP (найти IP по MAC-адресу).

### 2.4 Транспортный уровень

> Обеспечивает логическое соединение между двумя хостами.
>
> Главная задача – транспортировка пакетов.

Транспортный уровень OSI (уровень 4) является посредником (каналом) между уровнями приложений и сетевыми уровнями – фактически, он согласовывает их работу: транспортный уровень описывает сам механизм передачи данных, вне зависимости от их типа.

> Программы прикладного уровня генерируют данные, которыми необходимо обмениваться между узлами источника и назначения. Транспортный уровень отвечает за логические связи между приложениями, работающими на разных узлах.

Протоколы транспортного уровня TCP и UDP используют номера портов для управления несколькими одновременными сеансами связи.

> Примеры протоколов: TCP (надёжная доставка), UDP (ненадёжная доставка).

### 2.5 Сеансовый уровень

> Управляет взаимодействием между приложениями (прикладными процессами).
>
> Оперирует чистыми данными и отвечает за поддержку сеанса связи.

Сеансовый уровень OSI (уровень 5) служит для установления и поддержания связи между приложениями отправителя и получателя. На данном уровне происходит обмен данными для установления связи, поддержания ее в активном состоянии и для перезапуска сеансов, которые были прерваны или неактивны в течение продолжительного времени.

> Сеансовый уровень обеспечивает взаимодействие между прикладными процессами независимо от метода и техники передачи информации (то есть, он занимается выделением ресурсов, вызовом нужных приложений и так далее).

Именно сеансовый уровень аутентифицирует право пользователя на доступ к услуге, синхронизирует приложения, а также устанавливает соединение и поддерживает его между двумя удалёнными программами.

> Примеры протоколов: RPC (удалённый вызов процедур), NetBIOS (служба сессий на старых компах).
>
> Видеозвонок по сети происходит через сеансовый уровень.

### 2.6 Уровень представления данных

> Определяет синтаксис передаваемой информации, то есть форму передачи информации: текста, графики, звука.
>
> Занимается шифрованием данных, когда при передаче их необходимо защитить. 

Уровень представления OSI (уровень 6) служит для приведения данных, переданных транспортным уровнем, в вид доступный прикладному уровню. То есть, на нём форматируются данные для уровня приложений и устанавливаются стандарты форматов файлов.

> Фактически, данный уровень представляет сообщение в той форме, которая необходима получателю.

Следовательно, функции уровня сводятся к обеспечению шифровки/дешифровки данных, а также к их сжатию/распаковке.

> Примеры протоколов: ASCII (соответствие кодировок), SSL (криптография), TLS (криптография покруче).

### 2.7 Прикладной уровень

> Своеобразный GUI между моделью OSI и пользователем.

Прикладной уровень OSI (уровень 7) обеспечивает работу и взаимодействие сетевых приложений с базовой сетью, по которой передаются сообщения. Данный уровень определяет семантику информации, то есть её смысловое содержание.

> Протоколы уровня приложений используются для обмена данными между программами, выполняемыми на узле источника и узле назначения.

Основные функции уровня сводятся к обеспечению интерфейса между пользователем и общесетевыми службами, а также аутентификация пользователя по имени и паролю.

На прикладном уровне работают браузеры, всякие приложения типа Steam и BattleNet.

> Примеры протоколов: HTTP (передача данных через запросы), FTP (передача файлов по сети), Telnet (связь через терминал), SSH (безопасное удалённое подключение), SMTP (передача почты), DHCP (динамическая настройка IP на узле).

### 2.8 Инкапсуляция

В рамках сетевых моделей, к сегментации добавляется ещё одно свойство: по мере перехода данных от приложения к физической среде, на каждом уровне к нему добавляется специальная информация уровня. Этот процесс называется **инкапсуляцией** (это как собирать матрёшку), а обратное снятие информации уровня – **деинкапсуляцией** (это как добираться до самой маленькой матрёшки).

> Для передачи данных по сети, исходные данные сначала оборачиваются в матрёшку  из специальной информации, а затем разворачиваются из неё.
>
> На каждом уровне, матрёшка представляет собой массив данных, который называется **единицей данных протокола (PDU)**. И на каждом уровне, PDU имеет своё название:
>
> - **Данные** на уровне приложений;
> - **Сегмент** на транспортном уровне;
> - **Пакет** на сетевом уровне;
> - **Кадр** на канальном уровне;
> - **Биты** на физическом уровне.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1J5cnR4DpPLT2rWhVyDJxPV1juUcqmLEw" style=" zoom: 50%;"><b><p style="text-align: center;">Функционал PDU по уровням модели OSI</p></b></p>

## 3. Задача

Составьте блок-схему и напишите программу тестовой проверки знаний. Программа должна вывести 10 примеров (например, вычисления значений таблицы умножения), задающихся случайным образом и выставить оценку за 10 правильных ответов – «отлично», за 9 и 8 – «хорошо», за 7 и 6 «удовлетворительно», за 6 и менее – «плохо».

****

#### Пафосное решение:

```python
import numpy as np

def generate_numbers(count, num_start, num_end):
    mul1 = np.random.randint(num_start, num_end, size=count)
    mul2 = np.random.randint(num_start, num_end, size=count)
    for i in range(count):
        yield mul1[i], mul2[i]

def quiz(count, start_number, end_number):
    correct_answers = 0
    for num1, num2 in generate_numbers(count, start_number, end_number):
        res = input(f'{num1} * {num2} =')
        if res.isdigit() and num1*num2 == int(res):
            print('Правильно!')
            correct_answers += 1
        else:
            print('Неверно!')
    
    if correct_answers == 10:
        return 'Отлично'
    elif correct_answers in [9, 8]:
        return 'Хорошо'
    elif correct_answers in [7, 6]:
        return 'Удовлетворительно'
    else:
        return 'Плохо'

TOTAL = 10
start_number, end_number = 1, 13  # Диапазон чисел в примерах
result = quiz(TOTAL, start_number, end_number)
print(result)
```

#### Решение 71-х:

```python
import random

i=0
k=0
for i in range(10):
    a = random.randint(1, 9)
    b = random.randint(1, 9)
    print(a," x ",b )
    result = int(input())
    if ((a*b) == result):
        k = k+2;
if (k == 10):
    print("Отлично")
elif (8 <= k <= 9):
    print ("Хорошо")
elif (6 <= k <= 7):
    print("Удовлетворительно")
else:
    print("Плохо")
```

## 4. Задача

Составьте программу, которая рисует на экране шахматную доску.

****

#### Пафосное решение

```python
import numpy as np
import matplotlib.pyplot as plt

def checkerboard(n):
    A = np.zeros((n, n), dtype=int)
    A[1::2, ::2] = 1
    A[::2, 1::2] = 1
    return A


n = 10
fig, ax = plt.subplots()
ax.imshow(checkerboard(n), cmap=plt.cm.gray, interpolation='nearest')
plt.show();
```

#### Тупое решение

```python
import tkinter as tk
import math

root = tk.Tk() # Вывод окна
root.title("Шахматная доска")
N = 5

h, w = 600, 600
canvas = tk.Canvas(root);
canvas["height"], canvas["width"] = h, w
canvas["background"] = "#eeeeff"
canvas["borderwidth"] = 2
canvas.pack()

x, y, c = 20, 20, 1
a = (h - (x + y)) / N
for i in range(N):
    while x < h-40:
        if c % 2 == 0:
            col = "white"
        else:
            col = "black"
        c += 1
        canvas.create_rectangle(x, y, x+a, y+a, fill=col)
        x += a
    x = 20
    y += a;
    if N%2 == 0:
        c += 1
tk.mainloop()
```
