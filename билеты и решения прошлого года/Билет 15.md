# Билет №15

## 1. Цели и задачи файловой системы (ФС). Примеры ФС и их особенности.

**Файл** – именованная область внешней памяти, в которую можно записывать и из которой можно считывать данные.

**Файловая система** (ФС) – часть ОС, назначение которой состоит в предоставлении пользователю интерфейса для работы с данными, хранящимися во внешней памяти.

> ФС играет роль промежуточного слоя, экранирующего все сложности физической организации долговременного хранилища данных, и создающего для программ более простую логическую модель этого хранилища, а также предоставляя им набор удобных в использовании команд для манипулирования файлами.

**Цели использования файловой системы:**

- Экранирование физической организации долговременного хранилища данных;
- Создание простой логической модели этого хранилища;
- Предоставление программам и пользователям удобного набора команд для манипулирования файлами.

**Файловые системы решают несколько задач:**

- Определение правил построения имен файлов и каталогов;
- Определение правил и формы размещения файлов на диске;
- Предоставление программам функций для работы с файлами;
- Обеспечение защиты данных в случае сбоев и ошибок;
- Обеспечение разграничения прав доступа к данным для каждого пользователя;
- Обеспечение совместной работы с файлами.

У каждой ОС есть свой популярный набор файловых систем: Windows (FAT32, NTFS, exFAT), Linux (ext), MAC (HFS):

- `FAT`. ФС, в основе которой лежит **файловая таблица** – она хранит в себе записи об имеющихся файлах, времени их создания и последнего доступа к ним. Версии FAT отличаются только длиной записи блока.
  В FAT нет журналирования, поэтому чтение/запись идёт быстрее (меньше времени тратится на логи). Она быстро работает с малыми и средними каталогами, но с фрагментированным диском и большими каталогами (по количеству файлов) – очень медленно.

  > FAT32 до сих пор используется для небольших флешек и старого оборудования, хоть и не поддерживает файлы размером больше 4 Гб.
  >
  > FAT64 известна как exFAT, она часто применяется для ёмких флешек и карт памяти. Может работать не только с Windows, но и с MAC.

- `NTFS`. Журналируемая (с продвинутым логированием) ФС. Как и FAT, основывается на таблицах, однако в NTFS они более совершенные и называются MFT. Строкам MFT соответствуют файлы раздела, а столбцы – атрибуты файлов (дата создания, размер, права доступа и прочее).
  NTFS рационально использует место на носителе, она надёжна и быстро работает с большими файлами. Однако, не поддерживает системы ниже Windows NT и имеет ряд ограничений при работе с другими ОС (MAC и Linux читают NTFS, но не могут записывать).

  > NTFS – родная система для современной винды.

- `ext`. Построена на ядре Linux, журналируемость опциональна. Основной элемент ФС – **суперблок**, который содержит общую информацию о ФС и находится в 1024 байтах от начала раздела. Работоспособность ФС напрямую зависит от целостности суперблока.
  Низкий уровень фрагментации, активно улучшается разработчиками и поддерживается многими дистрибутивами Linux. Однако, не поддерживается проверка контрольных сумм для данных, а производительность падает в разделах с размером около 100 Тб.
  В Windows и MAC работает только через специальное ПО и драйверы.

  > Одна из самых быстрых ФС на запись и чтение данных, но низкая отказоустойчивость: в домашних условиях, с NTFS восстановить данные гораздо вероятнее чем с ext4.

- `ZFS`. ФС, объединённая с менеджером логических томов. Поддерживает базовый функционал ФС и продвинутые возможности, такие как хранение файлов на нескольких устройствах, шифрование в реальном времени и создание снапшотов (копия файлов и каталогов ФС на определённый момент времени). Поддерживает огромный размер файлов, разделов и самой ФС.
  Из недостатков, не в полной мере поддерживается всеми современными ОС, и на многих аппаратных сборках лагает как дедушкина перфокарта.

  > Новомодное чудо заморское.

## 2. АТД - список. Реализация с помощью указателей.

Нотация **О-большое** описывает скорость работы алгоритма. Оно не сообщает скорость алгоритмов в секундах, а *позволяет сравнить количество операций*.

> Например, для списка размером **N** поиск должен выполнить **N** операций для нахождения последнего элемента, поэтому поиск имеет вид O(n).

**Указатель** – ячейка памяти, чьё значение указывает на другую ячейку.

> Указатель – своеобразный ярлык, который можно использовать для указания на какой-либо объект или другой ярлык.

**Абстрактные типы данных** являются некой математической моделью того, по какому макету должны храниться данные в структуре, и как должен обеспечиваться доступ ко всему объёму данных.

Один из основных представителей АТД – **связный список**. Это линейная структура, данные в которой хранятся последовательно (один элемент за другим, без разветвлений).

> Так как структура АТД списка линейна, то операция поиска ведётся вплоть до нахождения искомого: от первого элемента до последнего.
>
> Результат поиска позволяет найти место, куда можно вставить новый элемент или откуда удалить старый.

Следовательно, сложность поиска составляет O(n), а вставки/удаления/изменения – O(1).

> Базовые операции над списком: вставка, удаление, поиск, изменение.

Преимущество списка состоит в быстром добавлении и удалении элементов, однако доступ к ним осуществляется последовательно, и произвольный доступ к элементам может быть затруднительным.

АТД список можно **реализовать через массивы**, то есть создать несколько массивов разных типов и одного размера, и считать, что вся информация о каком-либо объекте списка разбивается по размерностям одного индекса.
Этот способ неудобен для динамических изменений массивов (удаляешь элемент – создаёшь новый массив и сдвигаешь в нём элементы), они также требуют больше места в памяти, но переход на конкретную позицию списка осуществляется за O(1).

АТД список можно **реализовывать через указатели**. Такой список представляет собой последовательность узлов, каждый из которых является объектом с данными и указанием на то, где находится следующий (иногда, и предыдущий) объект в последовательности. Эти списки – очень гибкая структура: их можно объединять или разбивать, вставлять или удалять любую позицию.

> Список на указателях – коробки с ярлыками, где между ярлыками протянута нить. В коробку можно хоть налить суп и кинуть в него учебник по философии, на ярлык не влияет.

<p style="text-align: center;"><img src="https://uploads.gamedev.net/monthly_03_2013/ccs-78358-0-08132700-1364443602.png" style=" zoom: 100%;"><b><p style="text-align: center;">Структура списка на указателях</p></b></p>

<p style="text-align: center;"><img src="https://uploads.gamedev.net/monthly_03_2013/ccs-78358-0-42463500-1364443619.png" style=" zoom: 100%;"><b><p style="text-align: center;">Вставка в список на указателях</p></b></p>

<p style="text-align: center;"><img src="https://uploads.gamedev.net/monthly_03_2013/ccs-78358-0-54565300-1364443635.png" style=" zoom: 100%;"><b><p style="text-align: center;">Удаление из списка на указателях</p></b></p>

**Краткая разница между реализациями через массивы и через указатели:**

1) В статических массивах нужно знать длину списка, а в динамических – учитывать, что изменение размера фактически создаёт новый список из старого и удаляет старый.
   В этом плане, реализация через указатели лучше, так как такой список можно динамически менять посредством выделения памяти под новый элемент, или освобождения за счёт удаления старого;
2) Из п.1 вытекает, что в плане использования памяти, рациональнее использовать реализацию на указателях, однако в плане обработки данных преобладают массивы.
   К примеру, переход на конкретную позицию списка быстрее в массивах, так как в них имеются индексы. В указательных реализациях, сначала нужно найти эту позицию, что увеличивает время поиска.

## 3. Задача

Составьте блок-схему и напишите программу. Ввести строку символов, состоящую из букв русского и латинского алфавита и пробелов. Вычислить и вывести на экран количество слов в строке (символы до пробела считаются словом).

****

#### **Пафосное решение:**

```python
s = 'Ввести строку символов состоящую из букв русского и латинского алфавита и пробелов'
s = s.split()
for word in s:
    print(f'"{word}"')
print()
print(len(s))
```

#### **Решение 71-х:**

```python
string = input("Введите строку: ")
string = string.split(" ")

count = 0
for s in string:
    s = s.replace(",", "")
    if s != None and s != "":
        count += 1
print('кол-во слов: ', count)
```

## 4. Задача

Перевести каждое из исходных чисел в двоичную систему счисления: 8*(24+3)/12. Выполнить действия в двоичной системе счисления. Результат перевести в десятичную систему счисления. Проверить правильность решения.

****

**Для перевода числа в двоичную систему, быстрее всего представить его как сумму степеней двойки:**

- $8_{10}=2^3=1000_{2}$

- $24_{10}=2^4+2^3=11000_{2}$

- $3_{10}=2^1+2^0=11_{2}$

- $12_{10}=2^3+2^2=1100_{2}$

**Сложение 2-чных чисел:** поразрядно складываем цифры в столбиках. Если в разряде в сумме получается 2, единица переносится в соседний слева разряд. (Всё как в обычной арифметике, просто в обычке перенос при 10).

**Вычитание 2-чных чисел:** как сложение, но вычитаемое записывается в обратном коде (все 1 меняются на 0, а все 0 – на 1, и к полученному числу прибавляется 1).

**Умножение и деление 2-чных чисел:** один в один как для обычных чисел.



<p style="text-align: center;"><img src="https://prog-cpp.ru/wp-content/uploads/2014/03/13div5.png" style=" zoom: 100%;"><b><p style="text-align: center;">Умножение и деление двоичных чисел</p></b></p>

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1wd0AlJp4mARZIynqrrJ8jgl4ieyt3Zuv" style=" zoom: 25%;"><b><p style="text-align: center;">Выполнение двоичных действий</p></b></p>

**Проверка:**

$8*(24+3)/12=8*27/12=18$