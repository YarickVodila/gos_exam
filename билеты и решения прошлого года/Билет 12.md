# Билет №12

## 1. Понятие компьютерного вируса, виды, вредоносные функции, пути распространения, проявление действия.

**Компьютерный вирус** – специально написанная программа, или часть программного кода, деструктивного характера. Он может внедряться в систему или код других программ, распространять свои копии по разнообразным каналам связи.

> В современной компьютерной безопасности, вирус – ЛЮБАЯ функция, заменяющая незаражённый объект на отличающийся от него заражённый объект.

Определить сложные вирусы трудно, обычно это делается через анализ свойств и поведения объекта, а также его местоположение в системе (вирусы часто вшиваются в системные файлы).

Основной вредоносный функционал вирусов:

Вирусы можно классифицировать по разному, популярны классификации по "среде обитания" и функционалу:

1. **Среда обитания** – где вирус обворачивает свои делишки.

   - **Программные вирусы**. Внедряются внутрь прикладных программ, размножаются через непровенное ПО и через заражение других программ.

     > Ставишь себе прогу из УрТИСИ – и хоба, программный вирус, плати за общагу.

   - **Загрузочные вирусы**. Внедряются в системные области носителей информации.

     > Втыкаешь флешку в комп УрТИСИ – и хоба, загрузочный вирус.

   - **Макровирусы**. Внедряются в популярные виды документов, редакторы которых имеют средства для исполнения скриптовых команд (MS Office).

     > Качаешь вордовскую методичку препода – и хоба, у тебя на компе Белкина.

2. **Функционал** – чо вирус делает.

   - **Черви** (**Worm**). Делает копии самого себя. В чистом виде, это нужно для захламления компа. В составном виде – для распространения других видов вирусов.

   - **Трояны** (**Trojan**). Маскируется внутри безвредных программ, при её запуске – делает разные штуки. Обычно, используется для тыринга или избиения личных данных пользователя.

   - **Маскировщики** (**RootKit**). Маскирует вредоносную активность. Используется как компонент вируса, который скрывает его присутствие и действия.

     > Если антивирус сразу крашится при запуске, а браузер закрывается при вбивании в поисковик слова "вирус" – работает маскировщик.

   - **Шпионы** (**SpyWare**). Тырят данные о действиях и поведении пользователя. В первую очередь, коммуниздят адреса, пароли и данные кредитных карт.

   - **Зомби** (**Zombie**). Позволяют незаметно и удалённо управлять заражённым компом (например, через службу удалённого доступа). Могут быть объединены в бот-нет сетку для DDOS атаки.

   - **Рекламщики** (**AdWare**). Встраиваются в программы и ОС, крутят пользователю рекламу курсов от инфоцыган (не путать с УрТИСИ) и браузера Амиго.

     > Тамбовский волк тебе амиго (с)

   - **Блокировщики** (**WinLock**). Блокируют пользователю доступ к ОС. При загрузке компа, пользователю выдаётся окно с обвинением в загрузке нелегального контента, а файлы компа шифруются. Окно якобы должно пропасть после перевода денег на указанный счёт, но в реальности – нет.

Основными **путями распространения вирусов** являются съёмные накопители данных (флешки, диски, карты памяти) и компьютерные сети (вложения в почтовых письмах, сетевые службы операционной системы, подмена данных при взаимодействии с сервером).

**Проявление действия вирусов**:

- Частые зависания и сбои в работе компьютера, его медленная работа;
- Ранее работавшие проги начинают неправильно работать, или не работать вообще. **Зог**;
- Проблемы с загрузкой операционной системы;
- Исчезновение файлов и папок, или искажение их содержимого;
- Изменение даты и времени модификации файлов;
- Изменение размеров файлов;
- Существенное уменьшение свободной памяти в ОЗУ;
- Существенная занятость ЦП в моменты, когда он ять не должен быть загружен;
- Вывод на экран непредусмотренных сообщений или изображений;
- Подача непредусмотренных звуковых сигналов.

## 2. Адресация сети Интернет по протоколам Ipv4 и Ipv6.

### 2.1 Характеристика протокола IP

Протокол IP был разработан как протокол с низкой нагрузкой. Он обеспечивает только те функции, которые необходимы для доставки пакета от узла источника к узлу назначения по взаимосвязанной системе сетей. IP не предназначен для мониторинга и управления потоком пакетов. Эти функции, при необходимости, выполняются другими протоколами на других уровнях, в первую очередь – протоколом TCP на уровне 4.

**Основные характеристики IP:**

- **Без установления соединения.**
  Перед отправкой пакетов данных соединение с хостом назначения не устанавливается.

  > Обмен данными без установления соединения аналогичен отправке письма без предварительного уведомления получателя.

- **Негарантированная доставка.**
  Протокол IP не гарантирует получение всех доставляемых пакетов.

- **Независимость от среды.**
  Канальный уровень в модели OSI отвечает за приём IP-пакета и его подготовку к транспортировке по среде передачи данных. Это означает, что пересылка пакетов IP не ограничивается какой-либо конкретной коммуникационной средой.

### 2.2 Структура адреса на примере IPv4

Адрес IPv4 является иерархическим и состоит из раздела сети и раздела хоста. Определяя ту или иную часть, необходимо обращать внимание не на десятичное значение, а на 32-битную последовательность, как показано на рисунке.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1J94cVgJOm5Hd3_L_mYBVZh-pnGGCp7G2" style=" zoom: 60%;"><b><p style="text-align: center;">Структура IPv4 адреса</p></b></p>

- Биты в сетевой части адреса должны быть одинаковыми у всех устройств, находящихся в одной сети;
- Биты в хостовой части адреса должны быть уникальными для каждого хоста в сети;
- Если два узла имеют одну битовую комбинацию в определенной сетевой части 32-битного потока, то эти два узла находятся в одной и той же сети.

Узел может определить, какая часть 32-битного потока является сетевой, а какая узловой с помощью **маски подсети** – 32-битового значения, отделяющего сетевую часть адреса от хостовой части.

В битовой форме, маска подсети – непрерывная последовательность единиц, за которой следует непрерывная последовательность нулей. Последовательность единичных битов имеет длину сетевой части адреса, и именно так узел может разделить сетевую и хостовую части адреса.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1Om10HxpFEP6vl9YBjLtbt1lGL2lu6FyM" style=" zoom: 60%;"><b><p style="text-align: center;">Наглядное разделение частей маской</p></b></p>

Идентификация сетевой и узловой частей IPv4 адреса происходит через побитовое применение операции "логическое И" к адресу и маске. То есть, маска под сети не содержит сетевой или узловой части IPv4-адреса; она лишь указывает компьютеру, где искать эти части в конкретном IPv4-адресе.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1nhmIy1Mzc8M8SF34C-iLObGtsGmGOn9V" style=" zoom: 60%;"><b><p style="text-align: center;">Выделение сетевой части IPv4 адреса</p></b></p>

Маска имеет сокращённую форму: так как в ней главную роль играет непрерывная последовательность битовых единиц, начинающаяся со старшего разряда, то можно представлять маску просто как количество единичных битов. Например, адрес `192.168.0.13` и маску `255.255.128.0` (17 единиц подряд, в битовой форме) можно объединить как  `192.168.0.13/17`, где `/17` и есть сокращённая запись маски – **длина префикса**.

Сетевой адрес также называется **префиксом** или **сетевым префиксом**. Длина префикса означает количество бит, установленных в единицу (1) в маске подсети.

### 2.3 Классовая адресация

На заре IPv4, адреса в интернете распределялись согласно классовой адресации стандарта RFC. Он разделяет одноадресные диапазоны на следующие классы:

- Класс A. Диапазон `от 0.0.0.0/8 до 127.0.0.0/8`. Разрабатывался для очень крупных сетей;
- Класс B. Диапазон `от 128.0.0.0/16 до 191.255.0.0/16`. Разрабатывался для средних и крупных сетей;
- Класс C. Диапазон `от 192.0.0.0/24 до 223.255.255.0/24`. Разрабатывался для небольших сетей;
- Класс D. Диапазон `от 224.0.0.0 до 239.0.0.0`. Разрабатывался для многоадресных рассылок;
- Класс E. Диапазон `от 240.0.0.0 до 255.0.0.0`. Разрабатывался для экспериментальных адресов.

С появлением World Wide Web, классическая адресация перестала эффективно распределять ограниченное адресное пространство IPv4. Ей на смену пришла бесклассовая адресация – она игнорирует правила классов.

В то время, с ограниченным количеством компьютеров, использующих Интернет, классическая адресация была эффективным средством распределения адресов. Так, сети классов A и B имеют очень большое количество адресов узлов, а класс C имеет очень мало. На сети класса А приходится 50% сетей IPv4. Это привело к тому, что большинство доступных адресов IPv4 не используются.

### 2.4 Сегментирование сетей

> **Сегментирование сети** – разделение сети на подсети.

Для создания IPv4-подсетей задействуются один или несколько бит из узловой части в качестве бит сетевой части. Для этого, расширяется маска подсети: биты заимствуются из узловой части адреса. Чем больше заимствовано бит из узловой части, тем больше подсетей можно создать. Чем больше бит, заимствованных для увеличения числа подсетей, тем меньше количество узлов в подсети.

Разделение сетей проще всего выполнить на границах октетов /8, /16 и /24. Важно помнить, что увеличение длины префикса сокращает число узлов в каждой подсети.

| **Длина префикса** | **Маска подсети** | **Маска подсети в двоичной системе (n = сеть, h = хост)**    | **# хостов** |
| :----------------- | :---------------- | :----------------------------------------------------------- | :----------- |
| **/8**             | **255**.0.0.0     | **`nnnnnnnn`**`.hhhhhhhh.hhhhhhhh.hhhhhhhh` **`11111111`**`.00000000.00000000.00000000` | 16 777 214   |
| **/16**            | **255.255**.0.0   | **`nnnnnnnn.nnnnnnnn`**`.hhhhhhhh.hhhhhhhh` **`11111111.11111111`**`.00000000.00000000` | 65 534       |
| **/24**            | **255.255.255**.0 | **`nnnnnnnn.nnnnnnnn.nnnnnnnn`**`.hhhhhhhh` **`11111111.11111111.11111111`**`.00000000` | 254          |

Некоторые подсети проще, чем другие. Если требуется большее количество подсетей, необходимо использовать IPv4-сеть с большим числом бит в узловой части для заимствования. Например, адрес сети 172.16.0.0 имеет маску по умолчанию /16 или 255.255.0.0. Данный адрес имеет по 16 бит в сетевой и узловой части. 16 бит в узловой части можно использовать для создания подсетей.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1KBrJHMqPJ2gB4bOufORXAd-ntEpQq2NP" style=" zoom: 80%;"><b><p style="text-align: center;">Количество созданных подсетей</p></b></p>

Стандартные схемы подсетей, вроде /16, создают подсети с одинаковым количеством узлов. Однако, не каждой создаваемой подсети потребуется столько хостов – по этой причине, многие занятые IPv4 адреса остаются неиспользуемыми.

Для решения этой проблемы была разработана **маска подсети переменной длины (VLSM)**.

Так, в предыдущем примере разделения на подсети, ко всем подсетям применялась одна маска подсети – то есть, все эти подсети содержали одинаковое число доступных адресов узлов.

> При традиционной схеме разделения сети на подсети, создаются подсети одинакового размера.

VLSM же позволяет разделять пространство сети на неравные части – VLSM-маска подсети может варьироваться в зависимости от количества бит, которые были заимствованы для конкретной подсети. Эти биты образуют «переменную» часть маски.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1wapzdZlihf_zWtQ8Pl9_O8W62Vx2Nfqv" style=" zoom: 60%;"><b><p style="text-align: center;">Average базовый IPv4 и enjoyer VLSM</p></b></p>

**Примечание**: При использовании VLSM, всегда нужно начинать с обеспечения соответствия требованиям к узлам в крупнейших подсетях. Разбиение продолжается до тех пор, пока не будет удовлетворено требование к узлам в наименьшей подсети.

### 2.5 Что не так с IPv4

На протяжении многих лет разрабатывались дополнительные протоколы и процессы для решения новых задач. Тем не менее даже в результате изменений IPv4 по-прежнему имеет три основных недостатка.

- **Нехватка IP-адресов.**
  IPv4 может предложить лишь ограниченное количество уникальных публичных IP4-адресов – примерно 4 миллиарда, чего недостаточно современному человечеству.
- **Нехватка сквозных соединений.**
  **Преобразование сетевых адресов (NAT)** представляет собой технологию, которая  позволяет различным устройствам совместно использовать один публичный IPv4-адрес, скрывая адреса узлов внутри сети.
  Это позволяет уменьшить количество используемых адресов, но может представлять проблему при использовании технологий, для которых необходимы сквозные соединения.
- **Повышенная сложность сети.**
  Хоть NAT и продлило срок службы IPv4, оно было предназначено лишь как механизм перехода на IPv6.
  NAT в своей разнообразной реализации создает дополнительную сложность в сети, создавая задержку и затрудняя поиск и устранение неисправностей.

### 2.6 IPv6: да придёт спаситель

IPv6 помогает преодолеть ограничения протокола IPv4 и значительно расширяет доступные возможности, предлагая функции, которые оптимально соответствуют текущим и прогнозируемым сетевым требованиям.

К улучшениям, которые предлагает протокол IPv6, относятся следующие.

- **Расширенное адресное пространство.**
  IPv6-адреса используют 128-битную иерархическую адресацию, в отличие от протокола IPv4, использующего 32 бита.
- **Улучшенная обработка пакетов.**
  Структура заголовка IPv6 была упрощена благодаря уменьшению количества полей.
- **Отсутствие необходимости в использовании NAT.**
  NAT был создан для временного разрешения нехватки адресов в IPv4, однако в IPv6 такой проблемы уже нет.

32-битное адресное пространство IPv4 предусматривает примерно `4 294 967 296` уникальных адресов. Адресное пространство протокола IPv6 поддерживает `340 282 366 920 938 463 463 374 607 431 768 211 456` или 340 ундециллионов адресов. Примерно столько песчинок можно найти на всех пляжах нашей планеты.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1g2tEXQYxnk1ypNYaxhyPLAy7l4z8513_" style=" zoom: 70%;"><b><p style="text-align: center;">Пространство адресов IP</p></b></p>

### 2.7 Инкапсуляция и маршрутизация IP

Протокол IP инкапсулирует сегмент транспортного уровня (уровень чуть выше сетевого уровня) или другие данные путем добавления заголовка IP. Заголовок протокола IP используется для доставки пакета на узел назначения.

Процесс инкапсуляции данных от уровня к уровню обеспечивает возможность разрабатывать и масштабировать сервисы на различных уровнях без влияния на другие уровни. То есть, сегменты транспортного уровня можно легко упаковать с помощью протоколов IPv4 или IPv6 или любого нового протокола, который может быть создан в будущем.

IP-заголовок проверяется устройствами уровня 3 (т.е. маршрутизаторами и коммутаторами уровня 3), когда он перемещается по сети к месту назначения.

> Информация об IP-адресации остается неизменной с момента выхода пакета с исходного хоста до момента его прибытия на хост назначения, за исключением случаев, когда она переводится устройством, выполняющим преобразование сетевых адресов (NAT) для IPv4.

Маршрутизаторы реализуют протоколы маршрутизации для маршрутизации пакетов между сетями. Во время маршрутизации, выполняемой этими промежуточными устройствами, учитывается содержимое заголовка только того пакета, который инкапсулирует сегмент. Во всех остальных случаях часть данных пакета (т.е. инкапсулированная единица данных протокола (PDU) транспортного уровня) во время выполнения процессов на сетевом уровне остается неизменной.

> IP-пакет может фрагментироваться маршрутизаторами по мере необходимости. Ответственность за его сборку лежит на принимающей стороне.

## 3. Задача

Напишите программу для торговой фирмы. При продаже товара предусмотрено начисление торговой скидки по следующим правилам. Если сумма покупки не превышает 1000 руб., скидка не предоставляется. Если куплено товара на общую сумму от 1001 до 3000 руб., предоставляется скидка 5% от стоимости товара. Если стоимость покупки превышает 3000 руб., предоставляется скидка 7% от стоимости товара. (Товар сформировать в виде списка, каждый товар имеет свою цену. Товар выбирать из списка).

****

```pascal
uses FormsABC;

const
goods: array of string = ('Носок', 'Шампунь', 'Морковка', 'Шапка', 'Шишка',
'Коврик', 'Телефон', 'Шоколадка', 'Кот', 'Ёлочка');

var
list := new ListBox();
f1 := new FlowBreak(10);
Value1 := new IntegerField('Штук:');
f2 := new FlowBreak(5);
Calculate := new Button('Купить');
f3 := new FlowBreak(5);
res := new TextLabel('Стоимость покупки: ');
discount := new TextLabel('Скидка');

ArrOfGoods: array [,] of string;
cost: array [0..9] of integer;


procedure MyClick;
var
cost: integer;
temp: string;
sum: real;
good: string;
begin
temp := list.SelectedItem.ToString.Split('-')[0];
good := Trim(list.SelectedItem.ToString.Split('-')[1]);
temp := temp.Remove(temp.Length - 3, 2);
cost := temp.ToInteger;
sum := cost * Value1.Value;
if sum < 1 then
begin
res.Text := 'Нельзя взять меньше 1 товара.';
discount.Text := 'Ошибка!';
end
else
begin
case round(sum) of
0..1000: begin discount.Text := 'Скидка НЕ предоставляется.'; end;
1001..3000: begin sum := sum * 0.95; discount.Text := 'Скидка в 5%.'; end;
else begin sum := sum * 0.93; discount.Text := 'Скидка в 7%.'; end;
end;

res.Text := 'Стоимость [' + Value1.Value.ToString + ' x ' + good + '] = ' + (sum).ToString + 'р.';
end;
end;

begin
Calculate.Click += MyClick;
SetLength(ArrOfGoods, 10, 2);
for var i := 0 to 9 do
begin
cost[i] := Random(600) + 200;
ArrOfGoods[i, 0] := goods[i];
ArrOfGoods[i, 1] := cost[i].ToString;
list.Items.Add(ArrOfGoods[i, 1] + 'р. - ' + ArrOfGoods[i, 0]);
end;
list.SelectedIndex := 0;
end.
```

## 4. Напишите (на псевдоязыке) процедуру обмена элементами в позициях p и NEXT(p) для однонаправленного связанного списка.

Один из основных представителей АТД – **связный список**. Это линейная структура, данные в которой хранятся последовательно (один элемент за другим, без разветвлений).

> Так как структура АТД списка линейна, то операция поиска ведётся вплоть до нахождения искомого: от первого элемента до последнего.
>
> Результат поиска позволяет найти место, куда можно вставить новый элемент или откуда удалить старый.

Следовательно, сложность поиска составляет O(n), а вставки/удаления/изменения – O(1).

> Базовые операции над списком: вставка, удаление, поиск, изменение.

Преимущество списка состоит в быстром добавлении и удалении элементов, однако доступ к ним осуществляется последовательно, и произвольный доступ к элементам может быть затруднительным.

АТД список можно **реализовывать через указатели**. Такой список представляет собой последовательность узлов, каждый из которых является объектом с данными и указанием на то, где находится следующий (иногда, и предыдущий) объект в последовательности. Эти списки – очень гибкая структура: их можно объединять или разбивать, вставлять или удалять любую позицию.

> Список на указателях – коробки с ярлыками, где между ярлыками протянута нить. В коробку можно хоть налить суп и кинуть в него учебник по философии, на ярлык не влияет.

<p style="text-align: center;"><img src="https://uploads.gamedev.net/monthly_03_2013/ccs-78358-0-08132700-1364443602.png" style=" zoom: 100%;"><b><p style="text-align: center;">Структура списка на указателях</p></b></p>

<p style="text-align: center;"><img src="https://uploads.gamedev.net/monthly_03_2013/ccs-78358-0-42463500-1364443619.png" style=" zoom: 100%;"><b><p style="text-align: center;">Вставка в список на указателях</p></b></p>

<p style="text-align: center;"><img src="https://uploads.gamedev.net/monthly_03_2013/ccs-78358-0-54565300-1364443635.png" style=" zoom: 100%;"><b><p style="text-align: center;">Удаление из списка на указателях</p></b></p>

**Однонаправленный связный список** – связный список, в котором "движение" только в одну сторону (можно переместиться из начала в конец, но не из конца в начало).

Позиции `p` и `NEXT(p)` означают некий элемент и следующий за ним элемент. Например:

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1A-5hQaUCK6qONjmkU5tOsmCk5E_cU_PN" style=" zoom: 100%;"><b><p style="text-align: center;">Однонаправленный связный список</p></b></p>

В указателях однонаправленного связного списка хранятся ссылки только на СЛЕДУЮЩИЙ элемент списка. Тогда, алгоритм обмена элементов следующий:

1) В указатель `Prev_p` ставится следующим элементом `Next_p`;
2) В указатель `Next_p` ставится следующим элементом `p`;
3) В указатель `p` ставится следующим элементом элемент, следующий для `Next_p`.

На *белкокоде* это выглядит так:

```pascal
pPred^.Next := NextP
NextP^.Next := p
p^.Next := NextP^.Next
```
