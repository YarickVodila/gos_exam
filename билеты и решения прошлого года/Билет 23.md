# Билет №23

## 1. Компиляторы и интерпретаторы. Структура компиляторов и интерпретаторов. Лексический, синтаксический и семантический анализаторы.

**Транслятор** – программа, переводящая входную программу на исходном язык в эквивалентную ей выходную программу на результирующем языке. Основные виды трансляторов: компилятор и интерпретатор.

**Компилятор**. Выполняет трансляцию исходной программы на машинный язык.
Команды исходного языка адаптируются, по организации и мощности, в команды машинного языка. *Компилятор берёт программу целиком и преобразует её в исполняемый компьютерный код.*
В процессе компиляции, текст программы разбирается на части и анализируется, а затем генерируется в командах машинном языке.

> Результат – программный код в машинной форме. При выполнении, его не надо переводить в машинный, поэтому требуется меньше времени на исполнение. Во время компиляции, исходный код проверяется на наличие синтаксических ошибок.
>
> Однако, так как программа транслируется целиком, для неё требуется больше памяти. Изменение программы невозможно без изменения исходного кода и его перекомпиляции. Если исходный код содержит ошибки, исполняемый файл не будет создан.
>
> C, C++, C#, Scala, Pascal.

С точки зрения формальных языков, функции компилятора:

1. Распознавать язык исходной программы.
2. Выполнять генерацию для языка результирующей программы, попутно оптимиизровать его.

Структурно, компилятор состоит из компонентов:

- **Лексический анализатор** или **лексер**. Часть компилятора, осуществляющая **лексический анализ** – процесс аналитического разбора последовательности символов исходного языка с целью формирования из них слов исходного языка.
- **Синтаксический анализатор** или **парсер**. Часть компилятора, осуществляющая **синтаксический анализ** (**парсинг**) – процесс сопоставления линейной последовательности слов языка с его формальной грамматикой.
- **Семантический анализатор**. Часть компилятора, осуществляющая **семантический анализ** – проверку смысловой правильности конструкции.
- **Генератор кода**. Часть компилятора, осуществляющая подготовку к генерации и непосредственно генерацию команд, составляющих предложения выходного языка и в целом текст результирующей программы.

> Существенное отличие интерпретатора от компилятора: так как интерпретатор исполняет команды по мере их поступления, то он не может выполнять оптимизацию исходной программы.

**Интерпретатор**. Осуществляет пооператорную трансляцию и выполнение исходной программы. В отличие от компилятора, не порождает на выходе программу на машинном языке. Распознав команду исходного языка сразу же выполняет её.

> Обработка данных может начинаться после написания даже одной команды. Это делаеть процесс разработки и отладки программ более гибким, а сам интерпретатор легко адаптировать к любым машинным архитектурам.
>
> Однако, скорость выполнения программ довольно низкая – в 50-100 раз медленнее программ, написанных в машинных кодах.
>
> PHP, Python, Perl, Ruby, R.

Структура интерпретатора аналогична структуре компилятора. В неё входят:

- **Лексер**. Разбивает входную строку на отдельные **токены** – минимальные неделимые части.
- **Парсер**. Производит синтаксический разбор дерева, формирует абстрактное синтаксическое дерево заданной структуры.
- **Виртуальная машина**. Ядро интерпретатора, исполняющее код.

## 2. Архитектурные особенности операционных систем.

**Операционная система** – комплекс программ, обеспечивающй взаимодействие всех устройств ЭВМ и позволяющий поользователю осуществлять управление ЭВМ.

> ОС – посредник между пользователем, программами и оборудованием компа.

**Главное назначение ОС** – управление ресурсами, главными из которых является аппаратура компьютера. ОС управляет вычислительным процессом и информационным обменом между процессором, памятью, внешними устройствами.

У операционных систем существует несколько базовых типов архитектур:

- **Монолитное ядро**.
  Предоставляет богатый набор абстракций оборудования. Все части монолитного ядра работают в одном адресном пространстве. Структурно, это такая схема операционной системы, при которой все компоненты её ядра являются составными частями одной программы, используют общие структуры данных и взаимодействуют друг с другом путём непосредственного вызова процедур. 

  > Плюсы: быстро работает, упрощённая разработка модулей.
  >
  > Минусы: сбой в одном из компонентов ядра может обрушить всю систему.
  >
  > Старейший способ организации операционных систем. Пример: большинство UNIX-систем. 

- **Модульное ядро**.
  Усовершенствованная модификация архитектуры монолитных ядер. В отличие от монолитных ядер, не требует полной перекомпиляции ядра при изменении состава аппаратного обеспечения компьютера. Вместо этого модульные ядра предоставляют тот или иной механизм подгрузки модулей ядра, поддерживающих то или иное аппаратное обеспечение (например, драйверов). При этом подгрузка модулей может быть как динамической (выполняемой «на лету», без перезагрузки ОС, в работающей системе), так и статической (выполняемой при перезагрузке ОС после переконфигурирования системы на загрузку тех или иных модулей).

  > Плюсы: разработка и проектирование ядра удобнее, процессы работы с ошибками легче.
  >
  > Минусы: не все части ядра можно представить в модульном виде, некоторые библиотеки и программы (вроде стандартной либы C++) нельзя использовать в чистом виде.
  >
  > Пример: современные дистрибутивы Linux.

- **Микроядро**.
  Предоставляет только элементарные функции управления процессами и минимальный набор абстракций для работы с оборудованием. Большая часть работы осуществляется специальными пользовательскими процессами – серверами. Решающим критерием «микроядерности» является размещение всех или почти всех драйверов и модулей в сервисных процессах, иногда с явной невозможностью загрузки любых модулей расширения в собственно микроядро, а также разработки таких расширений.

  > Плюсы: высокая степень надёжности, низкое потребление памяти и лёгкое подключение дополнительных модулей ядра.
  >
  > Минусы: низкая скорость работы из-за необходимости переключения между частями ядра, аппаратные средства доступны только через драйверы.
  >
  > Пример: Symbian OS. В гибридном виде, используется внутри MAC OS и Windows NT (Win XP, Win7 и новее).

- **Многоуровневая система**.
  Обобщение концепта модульной системы: ОС организована как иерархия уровней, где объект с уровня может вызвать только объект уровнем ниже. Уровни идут от интерфейса пользователя (высший уровень) до интерфейса аппаратной части (низший уровень). Чем ниже уровень – тем круче действия может выполнть модуль.

  > Плюсы: быстрая реализация, не нужно знать реализацию других слоёв, можно изменить один слой без изменения остальных.
  >
  > Минусы: низкая скорость работы из-за прохождения всех слоёв для ввода-вывода, общая разработка системы затруднена.
  >
  > Примеры: учебная система THE.

- **Виртуальная машина**.
  Программная или аппаратная среда, эмулирующая работу реального программного обеспечения. Базируется на технологии виртуализации – она позволяет использовать аппаратное обеспечение для создания его виртуальных копий. В данную среду можно инсталлировать ОС и осуществлять в ней все необходимые действия.

  > Плюсы: на одном устройстве можно использовать программы, написанные для разных ОС.
  >
  > Минусы: эффективность существенно снижена относительно реального компьютера, сама же система очень громоздка.
  >
  > Примеры: VirtualBox.

## 3. Как влияет модификатор static на класс/метод/поле?

**Объектно-ориентированное программирование** – концепция программирования, базирующаяся на использовании объектов.

> Если в структурной концепции главную роль играют **логика и понимание последовательности выполнения действия для достижения поставленной цели**, то в объектной концепции – **представление программы как системы взаимодействующих объектов**.

**Классом** в ООП понимается некая сущность, у которой можно смоделировать свойства и поведения. То есть, класс – некая идея сущности, своеобразный чертёж. Идею можно воплотить, и это воплощение будет называться **экземпляром** или **объектом**. У идеи есть некие характерные свойства – **атрибуты** или **поля**. Идее характерны некие способы взаимодействия – **методы**.

**Класс** – своеобразный чертёж объекта, позволяющий воплотить содержащуюся в нём идею в качестве экземпляра объекта.

**Класс** – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).

> `static` – своеобразный поводок к исходному классу, общий для всех его экземпляров.

Фича статического метода в том, что обычные методы у класса вызвать нельзя – только у его конкретного объекта. А вот статические методы позволяют для какого-нибудь класса `Треугольник` определить площадь по заданной формуле, например как `Треугольник.площадь(1, 2, 3)`.

Модификатор `static` обозначает некую реализацию поводка к классу, общую для всех экземпляров класса.

Суть модификатора `static` заключается в том, что он фактически привязывает конструкцию к классу, внутри которой она определяется.

Все эти конструкции будут общими для всех экземпляров класса.

Статическую конструкцию можно вызвать без создания объекта класса.

Статические методы не могут быть переопределены.

## 4. Задача

Объем информационного сообщения 12 288 битов (учитывая, что 1 байт = 8 битов). Чему равен объем информационного сообщения в Кбайтах?

****

1 байт = 8 бит, 1 килобайт (Кбайт) = 1000 байт.

Следовательно, $\frac{12288}{8 \cdot 1000}=\frac{1536}{1000}=1.536$ Кбайт.