# Билет №13

## 1. Понятие системы команд в ЭВМ. Классификация команд и их формат. Понятие адресации команд и данных в ЭВМ. Виды адресаций команд.

Важной составной частью архитектуры ЭВМ является **система команд** – соглашение о предоставляемых архитектурой средствах программирования. Система команд ЭВМ определяется структурой и форматами команд, а также списком (перечнем) команд и способами адресации.

> В системе команд описываются: определённые типы данных, инструкции, системы регистров, методы адресации, модели памяти, методы ввода и вывода, способы обработки прерываний и исключений.

**Командой** называется некоторым образом кодированная информация, определяющая выработку в ЭВМ последовательностей сигналов, предназначенных для выполнения определенной операции (действия) машины над заданными числовыми и нечисловыми кодами.

Команды можно классифицировать разными способами:

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1DUdqh1226PUoJ709N5nSCvJg1uRoi1K9" style=" zoom: 90%;"><b><p style="text-align: center;">Классификация команд ЭВМ</p></b></p>

В общем случае, команда должна как-то указывать:

- Подлежающую выполнению операцию;
- Адреса исходных данных, над которыми выполняется операция;
- Адрес, по которому должен быть помещён результат операции.

Следовательно, команда состоит из двух частей: операционной и адресной. В операционную часть заносится информация об операции (обычно, это код операции – `КОП`), в адресную – необходимые адреса.

В зависимости от количества адресов, разнятся и форматы команд:

- **Безадресный**. Команда используется для обращения к регистру.
- **Одноадресный**. Содержит адрес операнда, после выполнения команды записывает результат в ячейку по этому адресу.
- **Двухадресный**. Адрес операнда 1, адрес операнда 2. Результат записывается в один из этих адресов.
- **Трёхадресный**. Адрес операнда 1, адрес операнда 2, адрес для результата.
- **Четырёхадресный**. Адрес операнда 1, адрес операнда 2, адрес для результата, адрес следующей выполняемой команды.

Адресация также бывает нескольких видов:

- **Прямая**. Когда в адресном поле (поле адреса команды) располагается адрес операнда.
- **Непосредственная**. Когда в адресном поле располагается сам операнд.
- **Косвенная**. Когда в адресном поле располагается адрес ячейки, хранящей адрес операнда.
- **Относительная**. Когда адрес формируется как сумма базового адреса из регистра, и смещения из адресного поля.
- **Безадресная**. В команде нет поля адреса, а адрес операнда дефолтен или не нужен.

## 2. Принципы объектно-ориентированного программирования. Дайте определение понятию “метод”, что такое сигнатура метода, какие методы называются перегруженными?

**Объектно-ориентированное программирование** – концепция программирования, базирующаяся на использовании объектов.

> Если в структурной концепции главную роль играют **логика и понимание последовательности выполнения действия для достижения поставленной цели**, то в объектной концепции – **представление программы как системы взаимодействующих объектов**.

**Классом** в ООП понимается некая сущность, у которой можно смоделировать свойства и поведения. То есть, класс – некая идея сущности, своеобразный чертёж. Идею можно воплотить, и это воплощение будет называться **экземпляром** или **объектом**. У идеи есть некие характерные свойства – **атрибуты** или **поля**. Идее характерны некие способы взаимодействия – **методы**.

В современном ООП принято выделять пять основных принципов (механизмов):

- **Абстракция**. Сущности и взаимодействия можно смоделировать (представить в качестве некой концепции) как классы и методы.

  > Яблок много разных бывает – красные, зелёные, вкусные и червистые. Но городские жители при слове "яблоко" знают о каком объекте речь – они знают идею "яблочности". Вот эта идея "яблочности" и есть абстракция, то есть набор всех таких характеристик объекта.

- **Инкапсуляция**. Свойство системы, позволяющее объединять данные и методы, работающие с ними, в классе, попутно скрыв детали реализации от пользователя.

  > Наполнить желудок едой можно напрямую, положив еду в желудок. Это опасно, поэтому прямой доступ к желудку закрыт. Наполнение желудка происходит через элемент интерфейса "рот", а обычному пользователю не обязательно знать, что между ртом и желудком есть другие элементы говнокода.

- **Наследование**. Свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

  > На заводе есть общая идея стола, прямо таки столистый стол (**родительский класс**). Но людям нужны разные столы, и поэтому на заводе есть другие коробки с идеями письменного, обеденного или журнального столика – все они являются наследником (**дочерним классом**) идеи столистого стола, но по своему изменяют её.
  >
  > Я получил власть, которая и не снилась моему отцу!

- **Полиморфизм**. Свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

  > Человек может /есть. Кошка может /есть. Но эти действия проходят по разному, и в обычном диалоге нам не нужно уточнять "а вот кошка есть с помощью такого комплекта зубов, языка интегральной формы X и атомного излучателя", мы просто понимаем "кошка ест, чо те непонятно".
  >
  > Аналогично с вождением велосипеда – умеешь ездить на одном, сможешь поехать и на другом.

- **Композиция**. Объекты зачастую формируются или состоят из других объектов.

  > Компьютер можно считать объектом. Компьютер содержит разные устройства – видеокарту, процессор, материнскую плату и так далее. Эти устройства тоже можно считать объектами.
  > Компьютер – объект, содержащий другие объекты.

**Метод** – это последовательность команд, которые вызываются по определенному имени.

**Метод** – процедуры и функции, выполняющие действия над объектами класса, и объявление которых (процедур и функций) включено в описание класса.

**Метод** – функции для работы с атрибутами (характеристиками) класса.

**Метод** – характеристика поведения, присущего объекту.

Комбинация имени метода и его параметров, включая их количество и порядок, называется **сигнатурой**. А **контрактом метода** называется сочетание его сигнатуры и возвращаемого значения, включая его тип.

> Сигнатура метода – нечто, позволяющее однозначно идентифицировать конкретный метод.
> Сигнатура определяет входные параметры и их типы, а также выходной параметр и его тип.

В зависимости от языка, сигнатура метода включает в себя:

- `Java`: имя метода + параметры метода (порядок имеет значение);
- `C#`: имя метода + количество параметров + типы параметров + порядок параметров + модификаторы параметров.

**Перегрузка методов** – это возможность создавать несколько методов с одинаковым названием, но разными параметрами. Не все языки программирования позволяют это делать.

> Перегрузка методов – часть такой составляющей ООП, как полиморфизм.

Зачем нужна перегрузка методов? Всё очень просто. Например, существует метод для сложения чисел. Он универсальный и позволяет складывать числовые значения атрибутов. 

Но ведь его, по смыслу и логике, можно применить и для сложения объектов. Чтобы объекты определённых классов можно было складывать с помощью такого метода, нужно создать перегрузку метода, принимающего соответствующие параметры и под капотом производящего все манипуляции. Бум.

## 3. Задача

Создайте и заполните базу данных сотрудников предприятия связи, содержащей следующие таблицы: Сотрудники (отдел, табельный номер, фио, пол, код\_должности, дата рождения, стаж, семейное положение, дети); Штатное расписание (код\_должности, должность, оклад). Установите связь между таблицами. Сформируйте запросы: запрос 1, содержащий поля: отдел, фио, дата рождения, зарплата (зарплата считается оклад+премия, премия = 100% от оклада), отсортировав по отделам; запрос 2 вывести отдел, фио, дата рождения и стаж тех сотрудников, возраст которых больше среднего возраста всех сотрудников.

****

```sql
CREATE DATABASE IF NOT EXISTS связисты;  -- Создать БД если не существует
USE связисты;  -- Использовать БД

-- Создать таблицу "Расписание"
CREATE TABLE IF NOT EXISTS Расписание(
    код_должности INT PRIMARY KEY,
    должность VARCHAR(30),
     -- 12 - число знаков до ',', 2 - после
    оклад DECIMAL(12, 2)
);

INSERT INTO Расписание (код_должности, должность, оклад) 
    VALUES (1, 'доцент', 360.00);
INSERT INTO Расписание (код_должности, должность, оклад) 
    VALUES (2, 'магистрант', 215.00);
INSERT INTO Расписание (код_должности, должность, оклад) 
    VALUES (3, 'преподаватель', 310.00);

-- Создать таблицу "Сотрудники"
CREATE TABLE IF NOT EXISTS Сотрудники(
    табельный_номер INT PRIMARY KEY AUTO_INCREMENT, 
    фио VARCHAR(50),
    отдел VARCHAR(30),
    код_должности INT,
    пол VARCHAR(1),
    дата_рождения DATE,
    стаж INT,
    семья VARCHAR(1),
    дети INT,
    FOREIGN KEY (код_должности) REFERENCES Расписание (код_должности)
);

INSERT INTO Сотрудники (фио, отдел, код_должности, пол, дата_рождения, стаж, семья, дети) 
    VALUES ('Баранов П.Е.', 'ИСТ', 1, 'М', '1999-01-12', 13, 'Х', 1);
INSERT INTO Сотрудники (фио, отдел, код_должности, пол, дата_рождения, стаж, семья, дети) 
    VALUES ('Абрамова К.А.', 'МЭС', 1, 'Ж', '1989-04-26', 4, 'Х', 0);
INSERT INTO Сотрудники (фио, отдел, код_должности, пол, дата_рождения, стаж, семья, дети) 
    VALUES ('Семенов И.В.', 'МЭС', 2, 'М', '1979-05-13', 5, 'Р', 5);
INSERT INTO Сотрудники (фио, отдел, код_должности, пол, дата_рождения, стаж, семья, дети) 
    VALUES ('Ильиных Г.Р.', 'ИСТ', 3, 'Ж', '1985-03-05', 20, 'Б', 3);
```

>Сформируйте запросы:
>
>- запрос 1, содержащий поля: отдел, фио, дата рождения, зарплата (зарплата считается оклад+премия, премия= 100% от оклада), отсортировав по отделам;

```sql
SELECT
    отдел, фио, дата_рождения, оклад*2 AS Зарплата
FROM
    Сотрудники INNER JOIN Расписание USING (код_должности)
ORDER BY
    отдел
```

>- запрос 2 вывести отдел, фио, дата рождения и стаж тех сотрудников, возраст которых больше среднего возраста всех сотрудников.

```sql
SELECT
    отдел, фио, дата_рождения,
    оклад*2 AS Зарплата,
    (YEAR(CURRENT_DATE) - YEAR(дата_рождения)) -
    (DATE_FORMAT(CURRENT_DATE, '%m%d') < DATE_FORMAT(дата_рождения, '%m%d')) AS Возраст
FROM
    Сотрудники INNER JOIN Расписание USING (код_должности)
WHERE
    (YEAR(CURRENT_DATE) - YEAR(дата_рождения)) -
    (DATE_FORMAT(CURRENT_DATE, '%m%d') < DATE_FORMAT(дата_рождения, '%m%d'))
    >
    (SELECT
         AVG((YEAR(CURRENT_DATE) - YEAR(дата_рождения)) -
         (DATE_FORMAT(CURRENT_DATE, '%m%d') < DATE_FORMAT(дата_рождения, '%m%d')))
     FROM Сотрудники)
ORDER BY
    отдел
```

## 4. Преобразуйте выражение ((a+b)+c\*(d+e)+f)\*(g+h) в постфиксную форму.

Алгебраическое выражение можно записать в трёх формах: инфиксной, префиксной и постфиксной.

**Инфиксная форма**. Выражение, где операторы находятся **между** операторами.

> $2+2=4$

**Постфиксная форма**. Выражение, где операторы находятся **после** операторов.

> $2\;2+=4$

Исходное выражение записано в инфиксной форме.

>$((A+B)+C*(D+E)+F)*(G+H)$

Для наглядности, сначала нужно построить дерево для исходной формы:

1. Подписываем над выражением порядок операций;
2. Корнем дерева делаем операцию №1;
3. Фигачим в качестве узлов подписанные операторы, но в обратном порядке. К операторам добавляем потомков – аргументы операции. Если вместо аргумента идёт операция, фигачим её оператор и продолжаем пункт №3.

<p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&id=1n6WrJgQjjI4qT6XJnGcRUxvH1-QSbxgZ" style=" zoom: 40%;"><b><p style="text-align: center;">Префиксное дэрево</p></b></p>

Постфиксная форма составляется через BFS (обход в ширину).

**Метод обхода графа в ширину** или `BFS` – обход графа "как можно шире".

> Круги, от упавшего в воду камня, огибают препятствия при распространении.

**BFS распространяется по соседям в поисках цели, реализуется очередью.**